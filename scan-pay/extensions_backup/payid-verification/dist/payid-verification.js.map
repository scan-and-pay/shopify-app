{
  "version": 3,
  "sources": ["../../../../node_modules/react/cjs/react.development.js", "../../../../node_modules/react/index.js", "../../../../node_modules/scheduler/cjs/scheduler.development.js", "../../../../node_modules/scheduler/index.js", "../../../../node_modules/react-reconciler/cjs/react-reconciler.development.js", "../../../../node_modules/react-reconciler/index.js", "../../../../node_modules/react/cjs/react-jsx-runtime.development.js", "../../../../node_modules/react/jsx-runtime.js", "../../../../node_modules/@remote-ui/rpc/build/esm/memory.mjs", "../../../../node_modules/@remote-ui/core/build/esm/utilities.mjs", "../../../../node_modules/@remote-ui/core/build/esm/root.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/utilities/registration.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/extension.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Banner/Banner.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/BlockStack/BlockStack.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Button/Button.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Divider/Divider.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Heading/Heading.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Image/Image.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/InlineStack/InlineStack.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/Text/Text.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/checkout/components/View/View.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/render.mjs", "../../../../node_modules/@remote-ui/react/build/esm/render.mjs", "../../../../node_modules/@remote-ui/react/build/esm/reconciler.mjs", "../../../../node_modules/@remote-ui/react/build/esm/context.mjs", "../../../../node_modules/@remote-ui/react/build/esm/components.mjs", "../../../../node_modules/@remote-ui/react/build/esm/hooks/render.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/context.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Banner/Banner.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/BlockStack/BlockStack.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Button/Button.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Divider/Divider.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Heading/Heading.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Image/Image.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/InlineStack/InlineStack.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/Text/Text.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/components/View/View.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/api.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/errors.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/subscription.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/buyer-journey.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/attributes.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/shipping-address.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/cart-lines.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/checkout/hooks/settings.mjs", "../../../../extensions/payid-verification/src/Checkout.tsx", "../../../../node_modules/preact/src/constants.js", "../../../../node_modules/preact/src/util.js", "../../../../node_modules/preact/src/options.js", "../../../../node_modules/preact/src/create-element.js", "../../../../node_modules/preact/src/component.js", "../../../../node_modules/preact/src/diff/props.js", "../../../../node_modules/preact/src/create-context.js", "../../../../node_modules/preact/src/diff/children.js", "../../../../node_modules/preact/src/diff/index.js", "../../../../node_modules/preact/src/render.js", "../../../../node_modules/preact/src/clone-element.js", "../../../../node_modules/preact/src/diff/catch-error.js", "../../../../node_modules/preact/jsx-runtime/src/utils.js", "../../../../node_modules/preact/src/constants.js", "../../../../node_modules/preact/jsx-runtime/src/index.js"],
  "sourceRoot": "C:/Shopify/scan-pay/extensions/payid-verification/src",
  "sourcesContent": ["/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var ReactVersion = '18.3.1';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  transition: null\n};\n\nvar ReactCurrentActQueue = {\n  current: null,\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: false,\n  didScheduleLegacyUpdate: false\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactDebugCurrentFrame = {};\nvar currentExtraStackFrame = null;\nfunction setExtraStackFrame(stack) {\n  {\n    currentExtraStackFrame = stack;\n  }\n}\n\n{\n  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n    {\n      currentExtraStackFrame = stack;\n    }\n  }; // Stack implementation injected by the current renderer.\n\n\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentExtraStackFrame) {\n      stack += currentExtraStackFrame;\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner\n};\n\n{\n  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar assign = Object.assign;\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n  }\n\n  var propName; // Original props are copied\n\n  var props = assign({}, element.props); // Reserved names are extracted\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    var _child = children;\n    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      var escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n        return c;\n      });\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      var iterableChildren = children;\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(iterableChildren);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      var childrenString = String(children);\n      throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  var count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  var n = 0;\n  mapChildren(children, function () {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, function (child) {\n    return child;\n  }) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue) {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    // Add these to use same hidden class in VM as ServerContext\n    _defaultValue: null,\n    _globalName: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      },\n      displayName: {\n        get: function () {\n          return context.displayName;\n        },\n        set: function (displayName) {\n          if (!hasWarnedAboutDisplayNameOnConsumer) {\n            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n            hasWarnedAboutDisplayNameOnConsumer = true;\n          }\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nvar Uninitialized = -1;\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    var ctor = payload._result;\n    var thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(function (moduleObject) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, function (error) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      var pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    var moduleObject = payload._result;\n\n    {\n      if (moduleObject === undefined) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    {\n      if (!('default' in moduleObject)) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nfunction lazy(ctor) {\n  var payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!render.name && !render.displayName) {\n          render.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!type.name && !type.displayName) {\n          type.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  {\n    if (dispatcher === null) {\n      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\nfunction useContext(Context) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useInsertionEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nfunction useTransition() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\nfunction useDeferredValue(value) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\nfunction useId() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher$1.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher$1.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      setExtraStackFrame(stack);\n    } else {\n      setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n  }\n\n  {\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nfunction startTransition(scope, options) {\n  var prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  var currentTransition = ReactCurrentBatchConfig.transition;\n\n  {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    scope();\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nvar didWarnAboutMessageChannel = false;\nvar enqueueTaskImpl = null;\nfunction enqueueTask(task) {\n  if (enqueueTaskImpl === null) {\n    try {\n      // read require off the module object to get around the bundlers.\n      // we don't want them to detect a require and bundle a Node polyfill.\n      var requireString = ('require' + Math.random()).slice(0, 7);\n      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n      // version of setImmediate, bypassing fake timers if any.\n\n      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n    } catch (_err) {\n      // we're in a browser\n      // we can't use regular timers because they may still be faked\n      // so we try MessageChannel+postMessage instead\n      enqueueTaskImpl = function (callback) {\n        {\n          if (didWarnAboutMessageChannel === false) {\n            didWarnAboutMessageChannel = true;\n\n            if (typeof MessageChannel === 'undefined') {\n              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n            }\n          }\n        }\n\n        var channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(undefined);\n      };\n    }\n  }\n\n  return enqueueTaskImpl(task);\n}\n\nvar actScopeDepth = 0;\nvar didWarnNoAwaitAct = false;\nfunction act(callback) {\n  {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    var prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    var result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      var wasAwaited = false;\n      var thenable = {\n        then: function (resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(function (returnValue) {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, function (error) {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n      };\n\n      {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(function () {}).then(function () {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n\n              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      var returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        var _queue = ReactCurrentActQueue.current;\n\n        if (_queue !== null) {\n          flushActQueue(_queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        var _thenable = {\n          then: function (resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n        };\n        return _thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        var _thenable2 = {\n          then: function (resolve, reject) {\n            resolve(returnValue);\n          }\n        };\n        return _thenable2;\n      }\n    }\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  {\n    var queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(function () {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nvar isFlushing = false;\n\nfunction flushActQueue(queue) {\n  {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      var i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          var callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.act = act;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.startTransition = startTransition;\nexports.unstable_act = act;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useDeferredValue = useDeferredValue;\nexports.useEffect = useEffect;\nexports.useId = useId;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useInsertionEffect = useInsertionEffect;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.useSyncExternalStore = useSyncExternalStore;\nexports.useTransition = useTransition;\nexports.version = ReactVersion;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n", "/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var enableSchedulerDebugging = false;\nvar enableProfiling = false;\nvar frameYieldMs = 5;\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  return heap.length === 0 ? null : heap[0];\n}\nfunction pop(heap) {\n  if (heap.length === 0) {\n    return null;\n  }\n\n  var first = heap[0];\n  var last = heap.pop();\n\n  if (last !== first) {\n    heap[0] = last;\n    siftDown(heap, last, 0);\n  }\n\n  return first;\n}\n\nfunction siftUp(heap, node, i) {\n  var index = i;\n\n  while (index > 0) {\n    var parentIndex = index - 1 >>> 1;\n    var parent = heap[parentIndex];\n\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  var index = i;\n  var length = heap.length;\n  var halfLength = length >>> 1;\n\n  while (index < halfLength) {\n    var leftIndex = (index + 1) * 2 - 1;\n    var left = heap[leftIndex];\n    var rightIndex = leftIndex + 1;\n    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  var diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\nfunction markTaskErrored(task, ms) {\n}\n\n/* eslint-disable no-var */\n\nvar hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nif (hasPerformanceNow) {\n  var localPerformance = performance;\n\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date;\n  var initialTime = localDate.now();\n\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\n\nvar maxSigned31BitInt = 1073741823; // Times out immediately\n\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\nvar localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\nvar isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  var timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      var firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  var previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    if (enableProfiling) {\n      try {\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          var currentTime = exports.unstable_now();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        throw error;\n      }\n    } else {\n      // No catch in prod code path.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging )) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\n    var callback = currentTask.callback;\n\n    if (typeof callback === 'function') {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      var continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = exports.unstable_now();\n\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n      } else {\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    var firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n  var startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  var timeout;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -1\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n}\n\nfunction unstable_continueExecution() {\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nvar isMessageLoopRunning = false;\nvar scheduledHostCallback = null;\nvar taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\n\nvar frameInterval = frameYieldMs;\nvar startTime = -1;\n\nfunction shouldYieldToHost() {\n  var timeElapsed = exports.unstable_now() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  } // The main thread has been blocked for a non-negligible amount of time. We\n\n\n  return true;\n}\n\nfunction requestPaint() {\n\n}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    // Using console['error'] to evade Babel and ESLint\n    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    return;\n  }\n\n  if (fps > 0) {\n    frameInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    frameInterval = frameYieldMs;\n  }\n}\n\nvar performWorkUntilDeadline = function () {\n  if (scheduledHostCallback !== null) {\n    var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n\n    startTime = currentTime;\n    var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n    var hasMoreWork = true;\n\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  } // Yielding to the browser will give it a chance to paint, so we can\n};\n\nvar schedulePerformWorkUntilDeadline;\n\nif (typeof localSetImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof MessageChannel !== 'undefined') {\n  // DOM and Worker environments.\n  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\n}\n\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\n\nfunction cancelHostTimeout() {\n  localClearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\n\nvar unstable_requestPaint = requestPaint;\nvar unstable_Profiling =  null;\n\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_Profiling = unstable_Profiling;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_forceFrameRate = forceFrameRate;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_next = unstable_next;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = unstable_wrapCallback;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n", "/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  module.exports = function $$$reconciler($$$hostConfig) {\n    var exports = {};\n'use strict';\n\nvar React = require('react');\nvar Scheduler = require('scheduler');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar suppressWarning = false;\nfunction setSuppressWarning(newSuppressWarning) {\n  {\n    suppressWarning = newSuppressWarning;\n  }\n} // In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar assign = Object.assign;\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\nfunction get(key) {\n  return key._reactInternals;\n}\nfunction set(key, value) {\n  key._reactInternals = value;\n}\n\n// -----------------------------------------------------------------------------\n// the react-reconciler package.\n\nvar enableNewReconciler = false; // Support legacy Primer support on internal FB www\n\nvar enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\nvar enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\nvar warnAboutStringRefs = true; // -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\n\nvar enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n\nvar enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n\nvar enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\nvar FunctionComponent = 0;\nvar ClassComponent = 1;\nvar IndeterminateComponent = 2; // Before we know whether it is function or class\n\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\nvar HostComponent = 5;\nvar HostText = 6;\nvar Fragment = 7;\nvar Mode = 8;\nvar ContextConsumer = 9;\nvar ContextProvider = 10;\nvar ForwardRef = 11;\nvar Profiler = 12;\nvar SuspenseComponent = 13;\nvar MemoComponent = 14;\nvar SimpleMemoComponent = 15;\nvar LazyComponent = 16;\nvar IncompleteClassComponent = 17;\nvar DehydratedFragment = 18;\nvar SuspenseListComponent = 19;\nvar ScopeComponent = 21;\nvar OffscreenComponent = 22;\nvar LegacyHiddenComponent = 23;\nvar CacheComponent = 24;\nvar TracingMarkerComponent = 25;\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\nvar REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nfunction getWrappedName$1(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n} // Keep in sync with shared/getComponentNameFromType\n\n\nfunction getContextName$1(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentNameFromFiber(fiber) {\n  var tag = fiber.tag,\n      type = fiber.type;\n\n  switch (tag) {\n    case CacheComponent:\n      return 'Cache';\n\n    case ContextConsumer:\n      var context = type;\n      return getContextName$1(context) + '.Consumer';\n\n    case ContextProvider:\n      var provider = type;\n      return getContextName$1(provider._context) + '.Provider';\n\n    case DehydratedFragment:\n      return 'DehydratedFragment';\n\n    case ForwardRef:\n      return getWrappedName$1(type, type.render, 'ForwardRef');\n\n    case Fragment:\n      return 'Fragment';\n\n    case HostComponent:\n      // Host component type is the display name (e.g. \"div\", \"View\")\n      return type;\n\n    case HostPortal:\n      return 'Portal';\n\n    case HostRoot:\n      return 'Root';\n\n    case HostText:\n      return 'Text';\n\n    case LazyComponent:\n      // Name comes from the type in this case; we don't have a tag.\n      return getComponentNameFromType(type);\n\n    case Mode:\n      if (type === REACT_STRICT_MODE_TYPE) {\n        // Don't be less specific than shared/getComponentNameFromType\n        return 'StrictMode';\n      }\n\n      return 'Mode';\n\n    case OffscreenComponent:\n      return 'Offscreen';\n\n    case Profiler:\n      return 'Profiler';\n\n    case ScopeComponent:\n      return 'Scope';\n\n    case SuspenseComponent:\n      return 'Suspense';\n\n    case SuspenseListComponent:\n      return 'SuspenseList';\n\n    case TracingMarkerComponent:\n      return 'TracingMarker';\n    // The display name for this tags come from the user-provided type:\n\n    case ClassComponent:\n    case FunctionComponent:\n    case IncompleteClassComponent:\n    case IndeterminateComponent:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      break;\n\n  }\n\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags =\n/*                      */\n0;\nvar PerformedWork =\n/*                */\n1; // You can change the rest (and add more).\n\nvar Placement =\n/*                    */\n2;\nvar Update =\n/*                       */\n4;\nvar ChildDeletion =\n/*                */\n16;\nvar ContentReset =\n/*                 */\n32;\nvar Callback =\n/*                     */\n64;\nvar DidCapture =\n/*                   */\n128;\nvar ForceClientRender =\n/*            */\n256;\nvar Ref =\n/*                          */\n512;\nvar Snapshot =\n/*                     */\n1024;\nvar Passive =\n/*                      */\n2048;\nvar Hydrating =\n/*                    */\n4096;\nvar Visibility =\n/*                   */\n8192;\nvar StoreConsistency =\n/*             */\n16384;\nvar LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n\nvar HostEffectMask =\n/*               */\n32767; // These are not really side effects, but we still reuse this field.\n\nvar Incomplete =\n/*                   */\n32768;\nvar ShouldCapture =\n/*                */\n65536;\nvar ForceUpdateForLegacySuspense =\n/* */\n131072;\nvar Forked =\n/*                       */\n1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\n\nvar RefStatic =\n/*                    */\n2097152;\nvar LayoutStatic =\n/*                 */\n4194304;\nvar PassiveStatic =\n/*                */\n8388608; // These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\n\nvar MountLayoutDev =\n/*               */\n16777216;\nvar MountPassiveDev =\n/*              */\n33554432; // Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\n\nvar BeforeMutationMask = // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate | Snapshot | ( 0);\nvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\nvar LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n\nvar PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\n\nvar StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber;\n  var nearestMounted = fiber;\n\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    var nextNode = node;\n\n    do {\n      node = nextNode;\n\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  } // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n\n\n  return null;\n}\nfunction isFiberMounted(fiber) {\n  return getNearestMountedFiber(fiber) === fiber;\n}\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n\n      if (!instance._warnedAboutRefsInRender) {\n        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n      }\n\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n\n  if (!fiber) {\n    return false;\n  }\n\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var nearestMounted = getNearestMountedFiber(fiber);\n\n    if (nearestMounted === null) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  var a = fiber;\n  var b = alternate;\n\n  while (true) {\n    var parentA = a.return;\n\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n\n    var parentB = parentA.alternate;\n\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      var nextParent = parentA.return;\n\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      } // If there's no parent, we're at the root.\n\n\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        _child = _child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          _child = _child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n\n    if (a.alternate !== b) {\n      throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  } // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n\n\n  if (a.tag !== HostRoot) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    var match = findCurrentHostFiberImpl(child);\n\n    if (match !== null) {\n      return match;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    if (child.tag !== HostPortal) {\n      var match = findCurrentHostFiberWithNoPortalsImpl(child);\n\n      if (match !== null) {\n        return match;\n      }\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// This is a host config that's used for the `react-reconciler` package on npm.\n// It is only used by third-party renderers.\n//\n// Its API lets you pass the host config as an argument.\n// However, inside the `react-reconciler` we treat host config as a module.\n// This file is a shim between two worlds.\n//\n// It works because the `react-reconciler` bundle is wrapped in something like:\n//\n// module.exports = function ($$$config) {\n//   /* reconciler code */\n// }\n//\n// So `$$$config` looks like a global variable, but it's\n// really an argument to a top-level wrapping function.\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\nvar getPublicInstance = $$$hostConfig.getPublicInstance;\nvar getRootHostContext = $$$hostConfig.getRootHostContext;\nvar getChildHostContext = $$$hostConfig.getChildHostContext;\nvar prepareForCommit = $$$hostConfig.prepareForCommit;\nvar resetAfterCommit = $$$hostConfig.resetAfterCommit;\nvar createInstance = $$$hostConfig.createInstance;\nvar appendInitialChild = $$$hostConfig.appendInitialChild;\nvar finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\nvar prepareUpdate = $$$hostConfig.prepareUpdate;\nvar shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\nvar createTextInstance = $$$hostConfig.createTextInstance;\nvar scheduleTimeout = $$$hostConfig.scheduleTimeout;\nvar cancelTimeout = $$$hostConfig.cancelTimeout;\nvar noTimeout = $$$hostConfig.noTimeout;\nvar isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\nvar warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\nvar supportsMutation = $$$hostConfig.supportsMutation;\nvar supportsPersistence = $$$hostConfig.supportsPersistence;\nvar supportsHydration = $$$hostConfig.supportsHydration;\nvar getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\nvar beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\nvar afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\nvar preparePortalMount = $$$hostConfig.preparePortalMount;\nvar prepareScopeUpdate = $$$hostConfig.prepareScopeUpdate;\nvar getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\nvar getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\nvar detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n//      Microtasks\n//     (optional)\n// -------------------\n\nvar supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\nvar scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n//      Test selectors\n//     (optional)\n// -------------------\n\nvar supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\nvar findFiberRoot = $$$hostConfig.findFiberRoot;\nvar getBoundingRect = $$$hostConfig.getBoundingRect;\nvar getTextContent = $$$hostConfig.getTextContent;\nvar isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\nvar matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\nvar setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\nvar setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n//      Mutation\n//     (optional)\n// -------------------\n\nvar appendChild = $$$hostConfig.appendChild;\nvar appendChildToContainer = $$$hostConfig.appendChildToContainer;\nvar commitTextUpdate = $$$hostConfig.commitTextUpdate;\nvar commitMount = $$$hostConfig.commitMount;\nvar commitUpdate = $$$hostConfig.commitUpdate;\nvar insertBefore = $$$hostConfig.insertBefore;\nvar insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\nvar removeChild = $$$hostConfig.removeChild;\nvar removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\nvar resetTextContent = $$$hostConfig.resetTextContent;\nvar hideInstance = $$$hostConfig.hideInstance;\nvar hideTextInstance = $$$hostConfig.hideTextInstance;\nvar unhideInstance = $$$hostConfig.unhideInstance;\nvar unhideTextInstance = $$$hostConfig.unhideTextInstance;\nvar clearContainer = $$$hostConfig.clearContainer; // -------------------\n//     Persistence\n//     (optional)\n// -------------------\n\nvar cloneInstance = $$$hostConfig.cloneInstance;\nvar createContainerChildSet = $$$hostConfig.createContainerChildSet;\nvar appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\nvar finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\nvar replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\nvar cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\nvar cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n//     Hydration\n//     (optional)\n// -------------------\n\nvar canHydrateInstance = $$$hostConfig.canHydrateInstance;\nvar canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\nvar canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\nvar isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\nvar isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\nvar getSuspenseInstanceFallbackErrorDetails = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails;\nvar registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\nvar getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\nvar getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\nvar getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\nvar getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\nvar hydrateInstance = $$$hostConfig.hydrateInstance;\nvar hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\nvar hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\nvar getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\nvar commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\nvar commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\nvar clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\nvar clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\nvar shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\nvar didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\nvar didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\nvar didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\nvar didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\nvar didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\nvar didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\nvar didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\nvar didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\nvar didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\nvar didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\nvar didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\nvar didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\nvar didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\nvar didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\nvar errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\n\nfunction describeClassComponentFrame(ctor, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(ctor, true);\n  }\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar valueStack = [];\nvar fiberStack;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      error('Unexpected pop.');\n    }\n\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      error('Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nvar warnedAboutMissingGetChildContext;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n\n{\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nvar contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nvar didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    var instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  {\n    var childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  {\n    var instance = fiber.stateNode;\n    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      {\n        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n\n          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    var childContext = instance.getChildContext();\n\n    for (var contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + \".getChildContext(): key \\\"\" + contextKey + \"\\\" is not defined in childContextTypes.\");\n      }\n    }\n\n    {\n      var name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return assign({}, parentContext, childContext);\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  {\n    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  {\n    var instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    var node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            var Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nvar NoMode =\n/*                         */\n0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n\nvar ConcurrentMode =\n/*                 */\n1;\nvar ProfileMode =\n/*                    */\n2;\nvar StrictLegacyMode =\n/*               */\n8;\nvar StrictEffectsMode =\n/*              */\n16;\n\n// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nfunction clz32Fallback(x) {\n  var asUint = x >>> 0;\n\n  if (asUint === 0) {\n    return 32;\n  }\n\n  return 31 - (log(asUint) / LN2 | 0) | 0;\n}\n\n// If those values are changed that package should be rebuilt and redeployed.\n\nvar TotalLanes = 31;\nvar NoLanes =\n/*                        */\n0;\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n1;\nvar InputContinuousHydrationLane =\n/*    */\n2;\nvar InputContinuousLane =\n/*             */\n4;\nvar DefaultHydrationLane =\n/*            */\n8;\nvar DefaultLane =\n/*                     */\n16;\nvar TransitionHydrationLane =\n/*                */\n32;\nvar TransitionLanes =\n/*                       */\n4194240;\nvar TransitionLane1 =\n/*                        */\n64;\nvar TransitionLane2 =\n/*                        */\n128;\nvar TransitionLane3 =\n/*                        */\n256;\nvar TransitionLane4 =\n/*                        */\n512;\nvar TransitionLane5 =\n/*                        */\n1024;\nvar TransitionLane6 =\n/*                        */\n2048;\nvar TransitionLane7 =\n/*                        */\n4096;\nvar TransitionLane8 =\n/*                        */\n8192;\nvar TransitionLane9 =\n/*                        */\n16384;\nvar TransitionLane10 =\n/*                       */\n32768;\nvar TransitionLane11 =\n/*                       */\n65536;\nvar TransitionLane12 =\n/*                       */\n131072;\nvar TransitionLane13 =\n/*                       */\n262144;\nvar TransitionLane14 =\n/*                       */\n524288;\nvar TransitionLane15 =\n/*                       */\n1048576;\nvar TransitionLane16 =\n/*                       */\n2097152;\nvar RetryLanes =\n/*                            */\n130023424;\nvar RetryLane1 =\n/*                             */\n4194304;\nvar RetryLane2 =\n/*                             */\n8388608;\nvar RetryLane3 =\n/*                             */\n16777216;\nvar RetryLane4 =\n/*                             */\n33554432;\nvar RetryLane5 =\n/*                             */\n67108864;\nvar SomeRetryLane = RetryLane1;\nvar SelectiveHydrationLane =\n/*          */\n134217728;\nvar NonIdleLanes =\n/*                          */\n268435455;\nvar IdleHydrationLane =\n/*               */\n268435456;\nvar IdleLane =\n/*                        */\n536870912;\nvar OffscreenLane =\n/*                   */\n1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nfunction getLabelForLane(lane) {\n  {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nvar NoTimestamp = -1;\nvar nextTransitionLane = TransitionLane1;\nvar nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nfunction getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  var pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  var nextLanes = NoLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    var unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    var nextLane = getHighestPriorityLane(nextLanes);\n    var wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n    // only difference between default updates and transition updates is that\n    // default updates do not support refresh transitions.\n    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  var entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    var entanglements = root.entanglements;\n    var lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      var index = pickArbitraryLaneIndex(lanes);\n      var lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nfunction getMostRecentEventTime(root, lanes) {\n  var eventTimes = root.eventTimes;\n  var mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nfunction markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  var pendingLanes = root.pendingLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes;\n  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n\n  var lanes = pendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nfunction getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nfunction getLanesToRetrySynchronouslyOnError(root) {\n  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nfunction includesSyncLane(lanes) {\n  return (lanes & SyncLane) !== NoLanes;\n}\nfunction includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nfunction includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nfunction includesOnlyNonUrgentLanes(lanes) {\n  var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nfunction includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nfunction includesBlockingLane(root, lanes) {\n\n  var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nfunction includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nfunction isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== NoLanes;\n}\nfunction claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nfunction getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nfunction pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nfunction includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nfunction isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nfunction mergeLanes(a, b) {\n  return a | b;\n}\nfunction removeLanes(set, subset) {\n  return set & ~subset;\n}\nfunction intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nfunction laneToLanes(lane) {\n  return lane;\n}\nfunction higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nfunction createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  var laneMap = [];\n\n  for (var i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nfunction markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  var eventTimes = root.eventTimes;\n  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nfunction markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  var expirationTimes = root.expirationTimes;\n  var lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nfunction markRootFinished(root, remainingLanes) {\n  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  var entanglements = root.entanglements;\n  var eventTimes = root.eventTimes;\n  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n  var lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  var entanglements = root.entanglements;\n  var lanes = rootEntangledLanes;\n\n  while (lanes) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n    entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nfunction getBumpedLaneForHydration(root, renderLanes) {\n  var renderLane = getHighestPriorityLane(renderLanes);\n  var lane;\n\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nfunction addFiberToLanesMap(root, fiber, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nfunction movePendingFibersToMemoized(root, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  var memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(function (fiber) {\n        var alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\nfunction getTransitionsForLanes(root, lanes) {\n  {\n    return null;\n  }\n}\n\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\nvar currentUpdatePriority = NoLane;\nfunction getCurrentUpdatePriority() {\n  return currentUpdatePriority;\n}\nfunction setCurrentUpdatePriority(newPriority) {\n  currentUpdatePriority = newPriority;\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = currentUpdatePriority;\n\n  try {\n    currentUpdatePriority = priority;\n    return fn();\n  } finally {\n    currentUpdatePriority = previousPriority;\n  }\n}\nfunction higherEventPriority(a, b) {\n  return a !== 0 && a < b ? a : b;\n}\nfunction lowerEventPriority(a, b) {\n  return a === 0 || a > b ? a : b;\n}\nfunction isHigherEventPriority(a, b) {\n  return a !== 0 && a < b;\n}\nfunction lanesToEventPriority(lanes) {\n  var lane = getHighestPriorityLane(lanes);\n\n  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n    return DiscreteEventPriority;\n  }\n\n  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n    return ContinuousEventPriority;\n  }\n\n  if (includesNonIdleWork(lane)) {\n    return DefaultEventPriority;\n  }\n\n  return IdleEventPriority;\n}\n\n// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback = Scheduler.unstable_scheduleCallback;\nvar cancelCallback = Scheduler.unstable_cancelCallback;\nvar shouldYield = Scheduler.unstable_shouldYield;\nvar requestPaint = Scheduler.unstable_requestPaint;\nvar now = Scheduler.unstable_now;\nvar ImmediatePriority = Scheduler.unstable_ImmediatePriority;\nvar UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\nvar NormalPriority = Scheduler.unstable_NormalPriority;\nvar IdlePriority = Scheduler.unstable_IdlePriority;\n// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue = Scheduler.unstable_yieldValue;\nvar unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n\nvar rendererID = null;\nvar injectedHook = null;\nvar injectedProfilingHooks = null;\nvar hasLoggedError = false;\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n\n  if (!hook.supportsFiber) {\n    {\n      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');\n    } // DevTools exists, even though it doesn't support Fiber.\n\n\n    return true;\n  }\n\n  try {\n    if (enableSchedulingProfiler) {\n      // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n      // This gives DevTools a way to feature detect that isn't tied to version number\n      // (since profiling and timeline are controlled by different feature flags).\n      internals = assign({}, internals, {\n        getLaneLabelMap: getLaneLabelMap,\n        injectProfilingHooks: injectProfilingHooks\n      });\n    }\n\n    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n    injectedHook = hook;\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      error('React instrumentation encountered an error: %s.', err);\n    }\n  }\n\n  if (hook.checkDCE) {\n    // This is the real DevTools.\n    return true;\n  } else {\n    // This is likely a hook installed by Fast Refresh runtime.\n    return false;\n  }\n}\nfunction onScheduleRoot(root, children) {\n  {\n    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n      try {\n        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n      } catch (err) {\n        if ( !hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitRoot(root, eventPriority) {\n  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n    try {\n      var didError = (root.current.flags & DidCapture) === DidCapture;\n\n      if (enableProfilerTimer) {\n        var schedulerPriority;\n\n        switch (eventPriority) {\n          case DiscreteEventPriority:\n            schedulerPriority = ImmediatePriority;\n            break;\n\n          case ContinuousEventPriority:\n            schedulerPriority = UserBlockingPriority;\n            break;\n\n          case DefaultEventPriority:\n            schedulerPriority = NormalPriority;\n            break;\n\n          case IdleEventPriority:\n            schedulerPriority = IdlePriority;\n            break;\n\n          default:\n            schedulerPriority = NormalPriority;\n            break;\n        }\n\n        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n      } else {\n        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n      }\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onPostCommitRoot(root) {\n  if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n    try {\n      injectedHook.onPostCommitFiberRoot(rendererID, root);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitUnmount(fiber) {\n  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, fiber);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  {\n    if (typeof unstable_yieldValue === 'function') {\n      // We're in a test because Scheduler.unstable_yieldValue only exists\n      // in SchedulerMock. To reduce the noise in strict mode tests,\n      // suppress warnings and disable scheduler yielding during the double render\n      unstable_setDisableYieldValue(newIsStrictMode);\n      setSuppressWarning(newIsStrictMode);\n    }\n\n    if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n      try {\n        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n      } catch (err) {\n        {\n          if (!hasLoggedError) {\n            hasLoggedError = true;\n\n            error('React instrumentation encountered an error: %s', err);\n          }\n        }\n      }\n    }\n  }\n} // Profiler API hooks\n\nfunction injectProfilingHooks(profilingHooks) {\n  injectedProfilingHooks = profilingHooks;\n}\n\nfunction getLaneLabelMap() {\n  {\n    var map = new Map();\n    var lane = 1;\n\n    for (var index = 0; index < TotalLanes; index++) {\n      var label = getLabelForLane(lane);\n      map.set(lane, label);\n      lane *= 2;\n    }\n\n    return map;\n  }\n}\n\nfunction markCommitStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n      injectedProfilingHooks.markCommitStarted(lanes);\n    }\n  }\n}\nfunction markCommitStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n      injectedProfilingHooks.markCommitStopped();\n    }\n  }\n}\nfunction markComponentRenderStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n      injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n  }\n}\nfunction markComponentRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n      injectedProfilingHooks.markComponentRenderStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentErrored(fiber, thrownValue, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n      injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n    }\n  }\n}\nfunction markComponentSuspended(fiber, wakeable, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n      injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStopped();\n    }\n  }\n}\nfunction markPassiveEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n    }\n  }\n}\nfunction markPassiveEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStopped();\n    }\n  }\n}\nfunction markRenderStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n      injectedProfilingHooks.markRenderStarted(lanes);\n    }\n  }\n}\nfunction markRenderYielded() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n      injectedProfilingHooks.markRenderYielded();\n    }\n  }\n}\nfunction markRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n      injectedProfilingHooks.markRenderStopped();\n    }\n  }\n}\nfunction markRenderScheduled(lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n      injectedProfilingHooks.markRenderScheduled(lane);\n    }\n  }\n}\nfunction markForceUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n      injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n    }\n  }\n}\nfunction markStateUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n      injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar syncQueue = null;\nvar includesLegacySyncCallbacks = false;\nvar isFlushingSyncQueue = false;\nfunction scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\nfunction scheduleLegacySyncCallback(callback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\nfunction flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\nfunction flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    var i = 0;\n    var previousUpdatePriority = getCurrentUpdatePriority();\n\n    try {\n      var isSync = true;\n      var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n\n      setCurrentUpdatePriority(DiscreteEventPriority);\n\n      for (; i < queue.length; i++) {\n        var callback = queue[i];\n\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n\n  return null;\n}\n\n// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root) {\n  var currentState = root.current.memoizedState;\n  return currentState.isDehydrated;\n}\n\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack = [];\nvar forkStackIndex = 0;\nvar treeForkProvider = null;\nvar treeForkCount = 0;\nvar idStack = [];\nvar idStackIndex = 0;\nvar treeContextProvider = null;\nvar treeContextId = 1;\nvar treeContextOverflow = '';\nfunction isForkedChild(workInProgress) {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\nfunction getForksAtLevel(workInProgress) {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\nfunction getTreeId() {\n  var overflow = treeContextOverflow;\n  var idWithLeadingBit = treeContextId;\n  var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\nfunction pushTreeFork(workInProgress, totalChildren) {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId \u2014 it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n  warnIfNotHydrating();\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n\n  var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n  var slot = index + 1;\n  var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n    var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n    var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n    var restOfBaseId = baseId >> numberOfOverflowBits;\n    var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n\n    var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    var restOfNewBits = slot << restOfBaseLength;\n    var id = restOfNewBits | restOfBaseId;\n    var overflow = newOverflow + baseOverflow;\n    treeContextId = 1 << restOfLength | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    var newBits = slot << baseLength;\n\n    var _id = newBits | baseId;\n\n    var _overflow = baseOverflow;\n    treeContextId = 1 << length | _id;\n    treeContextOverflow = _overflow;\n  }\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n  // in its children.\n\n  var returnFiber = workInProgress.return;\n\n  if (returnFiber !== null) {\n    var numberOfForks = 1;\n    var slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number) {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id) {\n  return 1 << getBitLength(id) - 1;\n}\n\nfunction popTreeContext(workInProgress) {\n  // Restore the previous values.\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\nfunction getSuspendedTreeContext() {\n  warnIfNotHydrating();\n\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow\n    };\n  } else {\n    return null;\n  }\n}\nfunction restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  {\n    if (!getIsHydrating()) {\n      error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n    }\n  }\n}\n\n// This may have been an insertion or a hydration.\n\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\n\nvar didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary\n\nvar hydrationErrors = null;\n\nfunction warnIfHydrating() {\n  {\n    if (isHydrating) {\n      error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nfunction markDidThrowWhileHydratingDEV() {\n  {\n    didSuspendOrErrorDEV = true;\n  }\n}\nfunction didSuspendOrErrorWhileHydratingDEV() {\n  {\n    return didSuspendOrErrorDEV;\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction warnUnhydratedInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n          break;\n        }\n\n      case HostComponent:\n        {\n          var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, // TODO: Delete this argument when we remove the legacy root API.\n          isConcurrentMode);\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          var suspenseState = returnFiber.memoizedState;\n          if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n          break;\n        }\n    }\n  }\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  warnUnhydratedInstance(returnFiber, instance);\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  var deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber, fiber) {\n  {\n    if (didSuspendOrErrorDEV) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              {\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case HostText:\n              {\n                var _text = fiber.pendingProps;\n\n                var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, // TODO: Delete this argument when we remove the legacy root API.\n                _isConcurrentMode);\n                break;\n              }\n\n            case SuspenseComponent:\n              {\n                didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                break;\n              }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          var suspenseState = returnFiber.memoizedState;\n          var _parentInstance = suspenseState.dehydrated;\n          if (_parentInstance !== null) switch (fiber.tag) {\n            case HostComponent:\n              var _type2 = fiber.type;\n              var _props2 = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n              break;\n\n            case HostText:\n              var _text2 = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n        if (suspenseInstance !== null) {\n          var suspenseState = {\n            dehydrated: suspenseInstance,\n            treeContext: getSuspendedTreeContext(),\n            retryLane: OffscreenLane\n          };\n          fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n\n          var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n          // it during the first pass. Instead, we'll reenter it later.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber) {\n  return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n}\n\nfunction throwOnHydrationMismatch(fiber) {\n  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  var nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // Nothing to hydrate. Make it an insertion.\n\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  var firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    var prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    var returnFiber = hydrationParentFiber;\n\n    if (returnFiber !== null) {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n\n            var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            _isConcurrentMode2);\n            break;\n          }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  } // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n\n\n  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n    var nextInstance = nextHydratableInstance;\n\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch();\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction hasUnhydratedTailNodes() {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber) {\n  var nextInstance = nextHydratableInstance;\n\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspendOrErrorDEV = false;\n}\n\nfunction upgradeHydrationErrorsToRecoverable() {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nfunction queueHydrationError(error) {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\n\nvar ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\nvar NoTransition = null;\nfunction requestCurrentTransition() {\n  return ReactCurrentBatchConfig.transition;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\n\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    var currentKey = keysA[i];\n\n    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction describeFiber(fiber) {\n  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;\n  var source =  fiber._debugSource ;\n\n  switch (fiber.tag) {\n    case HostComponent:\n      return describeBuiltInComponentFrame(fiber.type);\n\n    case LazyComponent:\n      return describeBuiltInComponentFrame('Lazy');\n\n    case SuspenseComponent:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case SuspenseListComponent:\n      return describeBuiltInComponentFrame('SuspenseList');\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return describeFunctionComponentFrame(fiber.type);\n\n    case ForwardRef:\n      return describeFunctionComponentFrame(fiber.type.render);\n\n    case ClassComponent:\n      return describeClassComponentFrame(fiber.type);\n\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = '';\n    var node = workInProgress;\n\n    do {\n      info += describeFiber(node);\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\n\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\nvar current = null;\nvar isRendering = false;\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n\n    var owner = current._debugOwner;\n\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentNameFromFiber(owner);\n    }\n  }\n\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return '';\n    } // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n\n\n    return getStackByFiberInDevAndProd(current);\n  }\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = null;\n    current = null;\n    isRendering = false;\n  }\n}\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n    current = fiber;\n    isRendering = false;\n  }\n}\nfunction getCurrentFiber() {\n  {\n    return current;\n  }\n}\nfunction setIsRendering(rendering) {\n  {\n    isRendering = rendering;\n  }\n}\n\nvar ReactStrictModeWarnings = {\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {},\n  discardPendingWarnings: function () {}\n};\n\n{\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n    var node = fiber;\n\n    while (node !== null) {\n      if (node.mode & StrictLegacyMode) {\n        maybeStrictRoot = node;\n      }\n\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingUNSAFE_ComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    // Dedupe strategy: Warn once per component.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n    instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    // We do an initial pass to gather component names\n    var componentWillMountUniqueNames = new Set();\n\n    if (pendingComponentWillMountWarnings.length > 0) {\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillMountWarnings = [];\n    }\n\n    var UNSAFE_componentWillMountUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillMountWarnings = [];\n    }\n\n    var componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    }\n\n    var componentWillUpdateUniqueNames = new Set();\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillUpdateWarnings = [];\n    }\n\n    var UNSAFE_componentWillUpdateUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    } // Finally, we flush all the warnings\n    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n\n\n    if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n\n      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n    }\n\n    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n\n      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n    }\n\n    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n\n      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n    }\n\n    if (componentWillMountUniqueNames.size > 0) {\n      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n\n      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n    }\n\n    if (componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n\n      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n    }\n\n    if (componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n\n      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n    }\n  };\n\n  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n\n  var didWarnAboutLegacyContext = new Set();\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n\n    if (strictRoot === null) {\n      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\n      return;\n    } // Dedup strategy: Warn once per component.\n\n\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      if (fiberArray.length === 0) {\n        return;\n      }\n\n      var firstFiber = fiberArray[0];\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n      var sortedNames = setToSortedString(uniqueNames);\n\n      try {\n        setCurrentFiber(firstFiber);\n\n        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);\n      } finally {\n        resetCurrentFiber();\n      }\n    });\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingUNSAFE_ComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    pendingLegacyContextWarning = new Map();\n  };\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\nfunction checkPropStringCoercion(value, propName) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar didWarnAboutMaps;\nvar didWarnAboutGenerators;\nvar didWarnAboutStringRefs;\nvar ownerHasKeyUseWarning;\nvar ownerHasFunctionTypeWarning;\n\nvar warnForMissingKey = function (child, returnFiber) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child, returnFiber) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    child._store.validated = true;\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n\n    error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with \"Function components cannot have string refs\"\n      !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with \"Function components cannot be given refs\"\n      !(typeof element.type === 'function' && !isReactClass(element.type)) && // Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\n      element._owner) {\n        var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          {\n            error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst;\n\n      if (owner) {\n        var ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      var resolvedInst = inst;\n\n      {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      var ref = function (value) {\n        var refs = resolvedInst.refs;\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  var childString = Object.prototype.toString.call(newChild);\n  throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  {\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n\n    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  var payload = lazyType._payload;\n  var init = lazyType._init;\n  return init(payload);\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    var childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    var existingChildren = new Map();\n    var existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    var current = newFiber.alternate;\n\n    if (current !== null) {\n      var oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n       isCompatibleFamilyForHotReloading(current, element) ) || // Lazy types should reconcile their resolved type.\n      // We need to do this after the Hot Reloading check above,\n      // because hot reloading has different semantics than prod because\n      // it doesn't resuspend. So we can't let the call below suspend.\n      typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        var existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    var created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n\n            _created2.return = returnFiber;\n            return _created2;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init;\n            return createChild(returnFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init;\n            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init;\n          return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          var key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted \u2014 the behavior is unsupported and ' + 'could change in a future version.', key);\n\n          break;\n\n        case REACT_LAZY_TYPE:\n          var payload = child._payload;\n          var init = child._init;\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    {\n      // First, validate keys.\n      var knownKeys = null;\n\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (_newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n\n        previousNewFiber = _newFiber;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (_newFiber2 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks2 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks2);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (_newChildren) {\n        var knownKeys = null;\n\n        var _step = _newChildren.next();\n\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    var step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n\n        if (_newFiber3 === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n\n        previousNewFiber = _newFiber3;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks3 = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks3);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks4 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks4);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    var key = element.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        var elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n           isCompatibleFamilyForHotReloading(child, element) ) || // Lazy types should reconcile their resolved type.\n          // We need to do this after the Hot Reloading check above,\n          // because hot reloading has different semantics than prod because\n          // it doesn't resuspend. So we can't let the call below suspend.\n          typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n\n            var _existing = useFiber(child, element.props);\n\n            _existing.ref = coerceRef(returnFiber, child, element);\n            _existing.return = returnFiber;\n\n            {\n              _existing._debugSource = element._source;\n              _existing._debugOwner = element._owner;\n            }\n\n            return _existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    var key = portal.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\nfunction cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nfunction resetChildFibers(workInProgress, lanes) {\n  var child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n\nvar valueCursor = createCursor(null);\nvar rendererSigil;\n\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastFullyObservedContext = null;\nvar isDisallowedContextReadInDEV = false;\nfunction resetContextDependencies() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction enterDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = true;\n  }\n}\nfunction exitDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction pushProvider(providerFiber, context, nextValue) {\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n    context._currentValue = nextValue;\n\n    {\n      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n    context._currentValue2 = nextValue;\n\n    {\n      if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\nfunction popProvider(context, providerFiber) {\n  var currentValue = valueCursor.current;\n  pop(valueCursor, providerFiber);\n\n  if (isPrimaryRenderer) {\n    {\n      context._currentValue = currentValue;\n    }\n  } else {\n    {\n      context._currentValue2 = currentValue;\n    }\n  }\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  // Update the child lanes of all the ancestors, including the alternates.\n  var node = parent;\n\n  while (node !== null) {\n    var alternate = node.alternate;\n\n    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n      node.childLanes = mergeLanes(node.childLanes, renderLanes);\n\n      if (alternate !== null) {\n        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n      }\n    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n    }\n\n    if (node === propagationRoot) {\n      break;\n    }\n\n    node = node.return;\n  }\n\n  {\n    if (node !== propagationRoot) {\n      error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n}\nfunction propagateContextChange(workInProgress, context, renderLanes) {\n  {\n    propagateContextChange_eager(workInProgress, context, renderLanes);\n  }\n}\n\nfunction propagateContextChange_eager(workInProgress, context, renderLanes) {\n\n  var fiber = workInProgress.child;\n\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n\n  while (fiber !== null) {\n    var nextFiber = void 0; // Visit this fiber.\n\n    var list = fiber.dependencies;\n\n    if (list !== null) {\n      nextFiber = fiber.child;\n      var dependency = list.firstContext;\n\n      while (dependency !== null) {\n        // Check if the context matches.\n        if (dependency.context === context) {\n          // Match! Schedule an update on this fiber.\n          if (fiber.tag === ClassComponent) {\n            // Schedule a force update on the work-in-progress.\n            var lane = pickArbitraryLane(renderLanes);\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            // Inlined `enqueueUpdate` to remove interleaved update check\n\n            var updateQueue = fiber.updateQueue;\n\n            if (updateQueue === null) ; else {\n              var sharedQueue = updateQueue.shared;\n              var pending = sharedQueue.pending;\n\n              if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n              } else {\n                update.next = pending.next;\n                pending.next = update;\n              }\n\n              sharedQueue.pending = update;\n            }\n          }\n\n          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n          var alternate = fiber.alternate;\n\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n          }\n\n          scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n\n          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n          // dependency list.\n\n          break;\n        }\n\n        dependency = dependency.next;\n      }\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else if (fiber.tag === DehydratedFragment) {\n      // If a dehydrated suspense boundary is in this subtree, we don't know\n      // if it will have any context consumers in it. The best we can do is\n      // mark it as having updates.\n      var parentSuspense = fiber.return;\n\n      if (parentSuspense === null) {\n        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n      }\n\n      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n      var _alternate = parentSuspense.alternate;\n\n      if (_alternate !== null) {\n        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n      } // This is intentionally passing this fiber as the parent\n      // because we want to schedule this fiber as having work\n      // on its children. We'll use the childLanes on\n      // this fiber to indicate that a context has changed.\n\n\n      scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n      nextFiber = fiber.sibling;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n\n        var sibling = nextFiber.sibling;\n\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        } // No more siblings. Traverse up.\n\n\n        nextFiber = nextFiber.return;\n      }\n    }\n\n    fiber = nextFiber;\n  }\n}\nfunction prepareToReadContext(workInProgress, renderLanes) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n  var dependencies = workInProgress.dependencies;\n\n  if (dependencies !== null) {\n    {\n      var firstContext = dependencies.firstContext;\n\n      if (firstContext !== null) {\n        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n          // Context list has a pending update. Mark that this fiber performed work.\n          markWorkInProgressReceivedUpdate();\n        } // Reset the work-in-progress list\n\n\n        dependencies.firstContext = null;\n      }\n    }\n  }\n}\nfunction readContext(context) {\n  {\n    // This warning would fire if you read context inside a Hook like useMemo.\n    // Unlike the class check below, it's not enforced in production for perf.\n    if (isDisallowedContextReadInDEV) {\n      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n    }\n  }\n\n  var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n\n  if (lastFullyObservedContext === context) ; else {\n    var contextItem = {\n      context: context,\n      memoizedValue: value,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      if (currentlyRenderingFiber === null) {\n        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n      } // This is the first dependency for this component. Create a new list.\n\n\n      lastContextDependency = contextItem;\n      currentlyRenderingFiber.dependencies = {\n        lanes: NoLanes,\n        firstContext: contextItem\n      };\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n\n  return value;\n}\n\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\n\nvar concurrentQueues = null;\nfunction pushConcurrentUpdateQueue(queue) {\n  if (concurrentQueues === null) {\n    concurrentQueues = [queue];\n  } else {\n    concurrentQueues.push(queue);\n  }\n}\nfunction finishQueueingConcurrentUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (concurrentQueues !== null) {\n    for (var i = 0; i < concurrentQueues.length; i++) {\n      var queue = concurrentQueues[i];\n      var lastInterleavedUpdate = queue.interleaved;\n\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n        var lastPendingUpdate = queue.pending;\n\n        if (lastPendingUpdate !== null) {\n          var firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = firstInterleavedUpdate;\n          lastInterleavedUpdate.next = firstPendingUpdate;\n        }\n\n        queue.pending = lastInterleavedUpdate;\n      }\n    }\n\n    concurrentQueues = null;\n  }\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n}\nfunction enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n}\nfunction enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n} // Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\n\nvar unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  var alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n\n  {\n    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  var node = sourceFiber;\n  var parent = sourceFiber.return;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (node.tag === HostRoot) {\n    var root = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nvar hasForceUpdate = false;\nvar didWarnUpdateInsideUpdate;\nvar currentlyProcessingQueue;\n\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n}\n\nfunction initializeUpdateQueue(fiber) {\n  var queue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  var queue = workInProgress.updateQueue;\n  var currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    var clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nfunction createUpdate(eventTime, lane) {\n  var update = {\n    eventTime: eventTime,\n    lane: lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return null;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  if (isUnsafeClassRenderPhaseUpdate()) {\n    // This is an unsafe render phase update. Add directly to the update\n    // queue so we can process it immediately during the current render.\n    var pending = sharedQueue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n    // this fiber. This is for backwards compatibility in the case where you\n    // update a different component during render phase than the one that is\n    // currently renderings (a pattern that is accompanied by a warning).\n\n    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n  } else {\n    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n  }\n}\nfunction entangleTransitions(root, fiber, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  var current = workInProgress.alternate;\n\n  if (current !== null) {\n    var currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      var newFirst = null;\n      var newLast = null;\n      var firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        var update = firstBaseUpdate;\n\n        do {\n          var clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  var lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          var nextState = payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        var _payload = update.payload;\n        var partialState;\n\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = _payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                _payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = _payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  var queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  var firstBaseUpdate = queue.firstBaseUpdate;\n  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  var pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    var lastPendingUpdate = pendingQueue;\n    var firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    var current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      var currentQueue = current.updateQueue;\n      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    var newLanes = NoLanes;\n    var newBaseState = null;\n    var newFirstBaseUpdate = null;\n    var newLastBaseUpdate = null;\n    var update = firstBaseUpdate;\n\n    do {\n      var updateLane = update.lane;\n      var updateEventTime = update.eventTime;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          var _clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        var callback = update.callback;\n\n        if (callback !== null && // If the update was already committed, we should not queue its\n        // callback again.\n        update.lane !== NoLane) {\n          workInProgress.flags |= Callback;\n          var effects = queue.effects;\n\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          var _firstPendingUpdate = _lastPendingUpdate.next;\n          _lastPendingUpdate.next = null;\n          update = _firstPendingUpdate;\n          queue.lastBaseUpdate = _lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n\n    var lastInterleaved = queue.shared.interleaved;\n\n    if (lastInterleaved !== null) {\n      var interleaved = lastInterleaved;\n\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = interleaved.next;\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n  }\n\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // Commit the effects\n  var effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n\n  if (effects !== null) {\n    for (var i = 0; i < effects.length; i++) {\n      var effect = effects[i];\n      var callback = effect.callback;\n\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}\n\nvar NO_CONTEXT = {};\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  if (c === NO_CONTEXT) {\n    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\n\nvar SubtreeSuspenseContextMask = 1; // Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\n\nvar InvisibleParentSuspenseContext = 1; // Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\n\nvar ForceSuspenseFallback = 2;\nvar suspenseStackCursor = createCursor(DefaultSuspenseContext);\nfunction hasSuspenseContext(parentContext, flag) {\n  return (parentContext & flag) !== 0;\n}\nfunction setDefaultShallowSuspenseContext(parentContext) {\n  return parentContext & SubtreeSuspenseContextMask;\n}\nfunction setShallowSuspenseContext(parentContext, shallowContext) {\n  return parentContext & SubtreeSuspenseContextMask | shallowContext;\n}\nfunction addSubtreeSuspenseContext(parentContext, subtreeContext) {\n  return parentContext | subtreeContext;\n}\nfunction pushSuspenseContext(fiber, newContext) {\n  push(suspenseStackCursor, newContext, fiber);\n}\nfunction popSuspenseContext(fiber) {\n  pop(suspenseStackCursor, fiber);\n}\n\nfunction shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  var nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n\n  {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n}\nfunction findFirstSuspended(row) {\n  var node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        var dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      var didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}\n\nvar NoFlags$1 =\n/*   */\n0; // Represents whether effect should fire.\n\nvar HasEffect =\n/* */\n1; // Represents the phase in which the effect (not the clean-up) fires.\n\nvar Insertion =\n/*  */\n2;\nvar Layout =\n/*    */\n4;\nvar Passive$1 =\n/*   */\n8;\n\n// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\n\nvar workInProgressSources = [];\nfunction resetWorkInProgressVersions() {\n  for (var i = 0; i < workInProgressSources.length; i++) {\n    var mutableSource = workInProgressSources[i];\n\n    if (isPrimaryRenderer) {\n      mutableSource._workInProgressVersionPrimary = null;\n    } else {\n      mutableSource._workInProgressVersionSecondary = null;\n    }\n  }\n\n  workInProgressSources.length = 0;\n}\n// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\n\nfunction registerMutableSourceForHydration(root, mutableSource) {\n  var getVersion = mutableSource._getVersion;\n  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n  // Retaining it forever may interfere with GC.\n\n  if (root.mutableSourceEagerHydrationData == null) {\n    root.mutableSourceEagerHydrationData = [mutableSource, version];\n  } else {\n    root.mutableSourceEagerHydrationData.push(mutableSource, version);\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\nvar didWarnAboutMismatchedHooksForComponent;\nvar didWarnUncachedGetSnapshot;\n\n{\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nvar renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nvar currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nvar currentHook = null;\nvar workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nvar didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nvar didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\nvar localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nvar globalClientIdCounter = 0;\nvar RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nvar currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nvar hookTypesDev = null;\nvar hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nvar ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  {\n    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        var table = '';\n        var secondColumnStart = 30;\n\n        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          var oldHookName = hookTypesDev[i];\n          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    {\n      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n    }\n  }\n\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (objectIs(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber$1 = workInProgress;\n\n  {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n    }\n  }\n\n  var children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    var numberOfReRenders = 0;\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      }\n\n      numberOfReRenders += 1;\n\n      {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n\n\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  return children;\n}\nfunction checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  var didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n  } else {\n    workInProgress.flags &= ~(Passive | Update);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nfunction resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    var hook = currentlyRenderingFiber$1.memoizedState;\n\n    while (hook !== null) {\n      var queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  var nextCurrentHook;\n\n  if (currentHook === null) {\n    var current = currentlyRenderingFiber$1.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  var nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n    var newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null,\n    stores: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  var hook = mountWorkInProgressHook();\n  var initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  var current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  var pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      var baseFirst = baseQueue.next;\n      var pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    var first = baseQueue.next;\n    var newState = current.baseState;\n    var newBaseState = null;\n    var newBaseQueueFirst = null;\n    var newBaseQueueLast = null;\n    var update = first;\n\n    do {\n      var updateLane = update.lane;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          var _clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = _clone;\n        } // Process this update.\n\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          var action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  } // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n\n\n  var lastInterleaved = queue.interleaved;\n\n  if (lastInterleaved !== null) {\n    var interleaved = lastInterleaved;\n\n    do {\n      var interleavedLane = interleaved.lane;\n      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = interleaved.next;\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  var dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  var dispatch = queue.dispatch;\n  var lastRenderPhaseUpdate = queue.pending;\n  var newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    var update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      var action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = mountWorkInProgressHook();\n  var nextSnapshot;\n  var isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedSnapshot = getSnapshot();\n\n        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n          error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  var inst = {\n    value: nextSnapshot,\n    getSnapshot: getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= Passive;\n  pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  var nextSnapshot = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedSnapshot = getSnapshot();\n\n      if (!objectIs(nextSnapshot, cachedSnapshot)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  var prevSnapshot = hook.memoizedState;\n  var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  var inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n  // checking whether we scheduled a subscription effect above.\n  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n    fiber.flags |= Passive;\n    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  var check = {\n    getSnapshot: getSnapshot,\n    value: renderedSnapshot\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    var stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  var handleStoreChange = function () {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction mountState(initialState) {\n  var hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  var effect = {\n    tag: tag,\n    create: create,\n    destroy: destroy,\n    deps: deps,\n    // Circular\n    next: null\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    var lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      var firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nfunction mountRef(initialValue) {\n  var hook = mountWorkInProgressHook();\n\n  {\n    var _ref2 = {\n      current: initialValue\n    };\n    hook.memoizedState = _ref2;\n    return _ref2;\n  }\n}\n\nfunction updateRef(initialValue) {\n  var hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var destroy = undefined;\n\n  if (currentHook !== null) {\n    var prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      var prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n  } else {\n    return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  return updateEffectImpl(Passive, Passive$1, create, deps);\n}\n\nfunction mountInsertionEffect(create, deps) {\n  return mountEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(Update, Layout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    var refCallback = ref;\n\n    var _inst = create();\n\n    refCallback(_inst);\n    return function () {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    var refObject = ref;\n\n    {\n      if (!refObject.hasOwnProperty('current')) {\n        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    var _inst2 = create();\n\n    refObject.current = _inst2;\n    return function () {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nvar updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n\nfunction updateDeferredValue(value) {\n  var hook = updateWorkInProgressHook();\n  var resolvedCurrentHook = currentHook;\n  var prevValue = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction rerenderDeferredValue(value) {\n  var hook = updateWorkInProgressHook();\n\n  if (currentHook === null) {\n    // This is a rerender during a mount.\n    hook.memoizedState = value;\n    return value;\n  } else {\n    // This is a rerender during an update.\n    var prevValue = currentHook.memoizedState;\n    return updateDeferredValueImpl(hook, prevValue, value);\n  }\n}\n\nfunction updateDeferredValueImpl(hook, prevValue, value) {\n  var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n\n  if (shouldDeferValue) {\n    // This is an urgent update. If the value has changed, keep using the\n    // previous value and spawn a deferred render to update it later.\n    if (!objectIs(value, prevValue)) {\n      // Schedule a deferred render\n      var deferredLane = claimNextTransitionLane();\n      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n      markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent\n      // from the latest value. The name \"baseState\" doesn't really match how we\n      // use it because we're reusing a state hook field instead of creating a\n      // new one.\n\n      hook.baseState = true;\n    } // Reuse the previous value\n\n\n    return prevValue;\n  } else {\n    // This is not an urgent update, so we can use the latest value regardless\n    // of what it is. No need to defer it.\n    // However, if we're currently inside a spawned render, then we need to mark\n    // this as an update to prevent the fiber from bailing out.\n    //\n    // `baseState` is true when the current value is different from the rendered\n    // value. The name doesn't really match how we use it because we're reusing\n    // a state hook field instead of creating a new one.\n    if (hook.baseState) {\n      // Flip this back to false.\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n\nfunction startTransition(setPending, callback, options) {\n  var previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  var prevTransition = ReactCurrentBatchConfig$1.transition;\n  ReactCurrentBatchConfig$1.transition = {};\n  var currentTransition = ReactCurrentBatchConfig$1.transition;\n\n  {\n    ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$1.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  var _mountState = mountState(false),\n      isPending = _mountState[0],\n      setPending = _mountState[1]; // The `start` method never changes.\n\n\n  var start = startTransition.bind(null, setPending);\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  var _updateState = updateState(),\n      isPending = _updateState[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  var _rerenderState = rerenderState(),\n      isPending = _rerenderState[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nvar isUpdatingOpaqueValueInRenderPhase = false;\nfunction getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n  {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId() {\n  var hook = mountWorkInProgressHook();\n  var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n\n  var identifierPrefix = root.identifierPrefix;\n  var id;\n\n  if (getIsHydrating()) {\n    var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    var localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    var globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  var hook = updateWorkInProgressHook();\n  var id = hook.memoizedState;\n  return id;\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      var eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    var alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      var lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        var prevDispatcher;\n\n        {\n          prevDispatcher = ReactCurrentDispatcher$1.current;\n          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          var currentState = queue.lastRenderedState;\n          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (objectIs(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            // TODO: Do we still need to entangle transitions in this case?\n            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          {\n            ReactCurrentDispatcher$1.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      var eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  var pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n} // TODO: Move to ReactFiberConcurrentUpdates?\n\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n\n  {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nvar ContextOnlyDispatcher = {\n  readContext: readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nvar HooksDispatcherOnMountInDEV = null;\nvar HooksDispatcherOnMountWithHookTypesInDEV = null;\nvar HooksDispatcherOnUpdateInDEV = null;\nvar HooksDispatcherOnRerenderInDEV = null;\nvar InvalidNestedHooksDispatcherOnMountInDEV = null;\nvar InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nvar InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\n{\n  var warnInvalidContextAccess = function () {\n    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  var warnInvalidHookAccess = function () {\n    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n}\n\nvar now$1 = Scheduler.unstable_now;\nvar commitTime = 0;\nvar layoutEffectStartTime = -1;\nvar profilerStartTime = -1;\nvar passiveEffectStartTime = -1;\n/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */\n\nvar currentUpdateIsNested = false;\nvar nestedUpdateScheduled = false;\n\nfunction isCurrentUpdateNested() {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled() {\n  {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n\n  commitTime = now$1();\n}\n\nfunction startProfilerTimer(fiber) {\n\n  profilerStartTime = now$1();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now$1();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = now$1() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber) {\n\n  if (layoutEffectStartTime >= 0) {\n    var elapsedTime = now$1() - layoutEffectStartTime;\n    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber) {\n\n  if (passiveEffectStartTime >= 0) {\n    var elapsedTime = now$1() - passiveEffectStartTime;\n    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer() {\n\n  layoutEffectStartTime = now$1();\n}\n\nfunction startPassiveEffectTimer() {\n\n  passiveEffectStartTime = now$1();\n}\n\nfunction transferActualDuration(fiber) {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  var child = fiber.child;\n\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n\n    return props;\n  }\n\n  return baseProps;\n}\n\nvar fakeInternalInstance = {};\nvar didWarnAboutStateAssignmentForComponent;\nvar didWarnAboutUninitializedState;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nvar didWarnAboutLegacyLifecyclesAndDerivedState;\nvar didWarnAboutUndefinedDerivedState;\nvar warnOnUndefinedDerivedState;\nvar warnOnInvalidCallback;\nvar didWarnAboutDirectlyAssigningPropsToState;\nvar didWarnAboutContextTypeAndContextTypes;\nvar didWarnAboutInvalidateContextType;\nvar didWarnAboutLegacyContext$1;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  didWarnAboutLegacyContext$1 = new Set();\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    var key = callerName + '_' + callback;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n\n      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentNameFromType(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n\n        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    var updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  var instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n    {\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      if (shouldUpdate === undefined) {\n        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n\n  {\n    var name = getComponentNameFromType(ctor) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    {\n      if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip\n      // this one.\n      (workInProgress.mode & StrictLegacyMode) === NoMode) {\n        didWarnAboutLegacyContext$1.add(ctor);\n\n        error('%s uses the legacy childContextTypes API which is no longer ' + 'supported and will be removed in the next major release. Use ' + 'React.createContext() instead\\n\\n.' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);\n      }\n\n      if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip\n      // this one.\n      (workInProgress.mode & StrictLegacyMode) === NoMode) {\n        didWarnAboutLegacyContext$1.add(ctor);\n\n        error('%s uses the legacy contextTypes API which is no longer supported ' + 'and will be removed in the next major release. Use ' + 'React.createContext() with static contextType instead.\\n\\n' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);\n      }\n\n      if (instance.contextTypes) {\n        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n\n        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    var hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n\n      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    var _state = instance.state;\n\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  set(instance, workInProgress);\n\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  var isLegacyContextConsumer = false;\n  var unmaskedContext = emptyContextObject;\n  var context = emptyContextObject;\n  var contextType = ctor.contextType;\n\n  {\n    if ('contextType' in ctor) {\n      var isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        var addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    var contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  }\n\n  var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n\n        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentNameFromType(ctor) || 'Component';\n\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n\n          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    {\n      error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n\n        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = {};\n  initializeUpdateQueue(workInProgress);\n  var contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else {\n    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n\n        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    var fiberFlags = Update;\n\n    {\n      fiberFlags |= LayoutStatic;\n    }\n\n    if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n      fiberFlags |= MountLayoutDev;\n    }\n\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var fiberFlags = Update;\n\n      {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags = Update;\n\n      {\n        _fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags2 = Update;\n\n      {\n        _fiberFlags2 |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags2 |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags2;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  var unresolvedOldProps = workInProgress.memoizedProps;\n  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  var unresolvedNewProps = workInProgress.pendingProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation   )) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n  // but I'm loath to refactor this function. This only happens for memoized\n  // components so it's not that common.\n  enableLazyContextPropagation   ;\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nfunction createCapturedValueAtFiber(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source),\n    digest: null\n  };\n}\nfunction createCapturedValue(value, digest, stack) {\n  return {\n    value: value,\n    source: null,\n    stack: stack != null ? stack : null,\n    digest: digest != null ? digest : null\n  };\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary, errorInfo) {\n  return true;\n}\n\nfunction logCapturedError(boundary, errorInfo) {\n  try {\n    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n    // This enables renderers like ReactNative to better manage redbox behavior.\n\n    if (logError === false) {\n      return;\n    }\n\n    var error = errorInfo.value;\n\n    if (true) {\n      var source = errorInfo.source;\n      var stack = errorInfo.stack;\n      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling\n      // `preventDefault()` in window `error` handler.\n      // We record this information as an expando on the error.\n\n      if (error != null && error._suppressLogging) {\n        if (boundary.tag === ClassComponent) {\n          // The error is recoverable and was silenced.\n          // Ignore it and don't print the stack addendum.\n          // This is handy for testing error boundaries without noise.\n          return;\n        } // The error is fatal. Since the silencing might have\n        // been accidental, we'll surface it anyway.\n        // However, the browser would have silenced the original error\n        // so we'll print it first, and then print the stack addendum.\n\n\n        console['error'](error); // Don't transform to our wrapper\n        // For a more detailed description of this block, see:\n        // https://github.com/facebook/react/pull/13384\n      }\n\n      var componentName = source ? getComponentNameFromFiber(source) : null;\n      var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : 'The above error occurred in one of your React components:';\n      var errorBoundaryMessage;\n\n      if (boundary.tag === HostRoot) {\n        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';\n      } else {\n        var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';\n        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      }\n\n      var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n      // We don't include the original error message and JS stack because the browser\n      // has already printed it. Even if the application swallows the error, it is still\n      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n      console['error'](combinedMessage); // Don't transform to our wrapper\n    } else {\n      // In production, we print the error directly.\n      // This will include the message, the JS stack, and anything the browser wants to show.\n      // We pass the error object instead of custom message so that the browser displays the error natively.\n      console['error'](error); // Don't transform to our wrapper\n    }\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nvar PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  var error = errorInfo.value;\n\n  update.callback = function () {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    var error$1 = errorInfo.value;\n\n    update.payload = function () {\n      return getDerivedStateFromError(error$1);\n    };\n\n    update.callback = function () {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  var inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      var error$1 = errorInfo.value;\n      var stack = errorInfo.stack;\n      this.componentDidCatch(error$1, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction attachPingListener(root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  var pingCache = root.pingCache;\n  var threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap$1();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(lanes)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(lanes);\n    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n    {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n  // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n  var wakeables = suspenseBoundary.updateQueue;\n\n  if (wakeables === null) {\n    var updateQueue = new Set();\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  var tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    var currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n  var node = returnFiber;\n\n  do {\n    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n      return node;\n    } // This boundary already captured during this render. Continue to the next\n    // boundary.\n\n\n    node = node.return;\n  } while (node !== null);\n\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (sourceFiber.tag === ClassComponent) {\n        var currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          var update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    var wakeable = value;\n    resetSuspendedComponent(sourceFiber);\n\n    {\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n        markDidThrowWhileHydratingDEV();\n      }\n    }\n\n\n    var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n\n      attachRetryListener(suspenseBoundary, root, wakeable);\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n      if (!includesSyncLane(rootRenderLanes)) {\n        // This is not a sync update. Suspend. Since we're not activating a\n        // Suspense boundary, this will unwind all the way to the root without\n        // performing a second pass to render a fallback. (This is arguably how\n        // refresh transitions should work, too, since we're not going to commit\n        // the fallbacks anyway.)\n        //\n        // This case also applies to initial hydration.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } // This is a sync/discrete update. We treat this case like an error\n      // because discrete renders are expected to produce a complete tree\n      // synchronously to maintain consistency with external state.\n\n\n      var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.\n      // The error will be caught by the nearest suspense boundary.\n\n      value = uncaughtSuspenseError;\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidThrowWhileHydratingDEV();\n\n      var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n\n      if (_suspenseBoundary !== null) {\n        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          _suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n\n        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n        return;\n      }\n    }\n  }\n\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  renderDidError(value); // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n  var workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          var lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n\n          var _lane = pickArbitraryLane(rootRenderLanes);\n\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction getSuspendedCache() {\n  {\n    return null;\n  } // This function is called when a Suspense boundary suspends. It returns the\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar didReceiveUpdate = false;\nvar didWarnAboutBadClass;\nvar didWarnAboutModulePatternComponent;\nvar didWarnAboutContextTypeOnFunctionComponent;\nvar didWarnAboutGetDerivedStateOnFunctionComponent;\nvar didWarnAboutFunctionRefs;\nvar didWarnAboutReassigningProps;\nvar didWarnAboutRevealOrder;\nvar didWarnAboutTailOptions;\nvar didWarnAboutDefaultPropsOnFunctionComponent;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var render = Component.render;\n  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    var type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      var resolvedType = type;\n\n      {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    {\n      var innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n\n      if ( Component.defaultProps !== undefined) {\n        var componentName = getComponentNameFromType(type) || 'Unknown';\n\n        if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n          error('%s: Support for defaultProps will be removed from memo components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n\n          didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n        }\n      }\n    }\n\n    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  {\n    var _type = Component.type;\n    var _innerPropTypes = _type.propTypes;\n\n    if (_innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(_innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(_type));\n    }\n  }\n\n  var currentChild = current.child; // This is always exactly one child\n\n  var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    var compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  var newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        var lazyComponent = outerMemoType;\n        var payload = lazyComponent._payload;\n        var init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    var prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n     workInProgress.type === current.type )) {\n      didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n      // would during a normal fiber bailout.\n      //\n      // We don't have strong guarantees that the props object is referentially\n      // equal during updates where we can't bail out anyway \u2014 like if the props\n      // are shallowly equal, but there's a local state or context update in the\n      // same batch.\n      //\n      // However, as a principle, we should aim to make the behavior consistent\n      // across different ways of memoizing a component. For example, React.memo\n      // has a different internal Fiber layout if you pass a normal function\n      // component (SimpleMemoComponent) versus if you pass a different type\n      // like forwardRef (MemoComponent). But this is an implementation detail.\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n      // affect whether the props object is reused during a bailout.\n\n      workInProgress.pendingProps = nextProps = prevProps;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  var prevState = current !== null ? current.memoizedState : null;\n\n  if (nextProps.mode === 'hidden' || enableLegacyHidden ) {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      // TODO: Consider how Offscreen should work with transitions in the future\n      var nextState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n\n      var nextBaseLanes;\n\n      if (prevState !== null) {\n        var prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n      } else {\n        nextBaseLanes = renderLanes;\n      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n      var _nextState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool,\n        transitions: null\n      };\n      workInProgress.memoizedState = _nextState;\n      workInProgress.updateQueue = null;\n      // to avoid a push/pop misalignment.\n\n\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      // Rendering at offscreen, so we can clear the base lanes.\n      var _nextState2 = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n\n      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    var _subtreeRenderLanes;\n\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      _subtreeRenderLanes = renderLanes;\n    }\n\n    pushRenderLanes(workInProgress, _subtreeRenderLanes);\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  {\n    workInProgress.flags |= Update;\n\n    {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      var stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n\n    {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          var _instance = workInProgress.stateNode;\n          var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n          var state = tempInstance.state;\n\n          _instance.updater.enqueueSetState(_instance, state, null);\n\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          var error$1 = new Error('Simulated error coming from DevTools');\n          var lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          var update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var instance = workInProgress.stateNode;\n  var shouldUpdate;\n\n  if (instance === null) {\n    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); // In the initial pass we might need to construct the instance.\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  {\n    var inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  var instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner$1.current = workInProgress;\n  var nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    {\n      stopProfilerTimerIfRunning();\n    }\n  } else {\n    {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    }\n\n    {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  var nextState = workInProgress.memoizedState;\n  var root = workInProgress.stateNode;\n  // being called \"element\".\n\n\n  var nextChildren = nextState.element;\n\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    var overrideState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache,\n      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n      transitions: nextState.transitions\n    };\n    var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      var recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else if (nextChildren !== prevChildren) {\n      var _recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n\n      var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n      workInProgress.child = child;\n      var node = child;\n\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = node.flags & ~Placement | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n  // Revert to client rendering.\n  resetHydrationState();\n  queueHydrationError(recoverableError);\n  workInProgress.flags |= ForceClientRender;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  var props = workInProgress.pendingProps;\n  var lazyComponent = elementType;\n  var payload = lazyComponent._payload;\n  var init = lazyComponent._init;\n  var Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  var resolvedProps = resolveDefaultProps(Component, props);\n  var child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  var hint = '';\n\n  {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); // Promote the fiber to a class and try rendering again.\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  var props = workInProgress.pendingProps;\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var value;\n  var hasId;\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      var componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner$1.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      var _componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);\n\n        didWarnAboutModulePatternComponent[_componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    {\n      var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName2]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);\n\n        didWarnAboutModulePatternComponent[_componentName2] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    var hasContext = false;\n\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    {\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  {\n    if (Component) {\n      if (Component.childContextTypes) {\n        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      var info = '';\n      var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      var warningKey = ownerName || '';\n      var debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n\n        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if ( Component.defaultProps !== undefined) {\n      var componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);\n\n        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      var _componentName4 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n        error('%s: Function components do not support contextType.', _componentName4);\n\n        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n      }\n    }\n  }\n}\n\nvar SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache(),\n    transitions: null\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  var cachePool = null;\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool: cachePool,\n    transitions: prevOffscreenState.transitions\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    var suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  var suspenseContext = suspenseStackCursor.current;\n  var showFallback = false;\n  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n  if (current === null) {\n    // Initial mount\n    // Special path for hydration\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n    var suspenseState = workInProgress.memoizedState;\n\n    if (suspenseState !== null) {\n      var dehydrated = suspenseState.dehydrated;\n\n      if (dehydrated !== null) {\n        return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n      }\n    }\n\n    var nextPrimaryChildren = nextProps.children;\n    var nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      var primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n    }\n  } else {\n    // This is an update.\n    // Special path for hydration\n    var prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      var _dehydrated = prevState.dehydrated;\n\n      if (_dehydrated !== null) {\n        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);\n      }\n    }\n\n    if (showFallback) {\n      var _nextFallbackChildren = nextProps.fallback;\n      var _nextPrimaryChildren = nextProps.children;\n      var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n      var _primaryChildFragment2 = workInProgress.child;\n      var prevOffscreenState = current.child.memoizedState;\n      _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n\n      _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    } else {\n      var _nextPrimaryChildren2 = nextProps.children;\n\n      var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);\n\n      workInProgress.memoizedState = null;\n      return _primaryChildFragment3;\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var progressedPrimaryFragment = workInProgress.child;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n  var fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    var deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    var progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    } // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  var fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  } // This will add the old fiber to the deletion list\n\n\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  var nextProps = workInProgress.pendingProps;\n  var primaryChildren = nextProps.children;\n  var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var fiberMode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n  var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    {\n      error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {\n  if (!didSuspend) {\n    // This is the first render pass. Attempt to hydrate.\n    // We should never be hydrating at this point because it is the first pass,\n    // but after we've already committed once.\n    warnIfHydrating();\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: When we delete legacy mode, we should make this error argument\n      // required \u2014 every concurrent mode path that causes hydration to\n      // de-opt to client rendering should have an error message.\n      null);\n    }\n\n    if (isSuspenseInstanceFallback(suspenseInstance)) {\n      // This boundary is in a permanent fallback state. In this case, we'll never\n      // get an update and we'll never be able to hydrate the final content. Let's just try the\n      // client side render instead.\n      var digest, message, stack;\n\n      {\n        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n\n        digest = _getSuspenseInstanceF.digest;\n        message = _getSuspenseInstanceF.message;\n        stack = _getSuspenseInstanceF.stack;\n      }\n\n      var error;\n\n      if (message) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        error = new Error(message);\n      } else {\n        error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');\n      }\n\n      var capturedValue = createCapturedValue(error, digest, stack);\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);\n    }\n    // any context has changed, we need to treat is as if the input might have changed.\n\n\n    var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n    if (didReceiveUpdate || hasContextChanged) {\n      // This boundary has changed since the first render. This means that we are now unable to\n      // hydrate it. We might still be able to hydrate it using a higher priority lane.\n      var root = getWorkInProgressRoot();\n\n      if (root !== null) {\n        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n          // Intentionally mutating since this render will get interrupted. This\n          // is one of the very rare times where we mutate the current tree\n          // during the render phase.\n          suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n          var eventTime = NoTimestamp;\n          enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n          scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);\n        }\n      } // If we have scheduled higher pri work above, this will probably just abort the render\n      // since we now have higher priority work, but in case it doesn't, we need to prepare to\n      // render something, if we time out. Even if that requires us to delete everything and\n      // skip hydration.\n      // Delay having to do this as long as the suspense timeout allows us.\n\n\n      renderDidSuspendDelayIfPossible();\n\n      var _capturedValue = createCapturedValue(new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));\n\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);\n    } else if (isSuspenseInstancePending(suspenseInstance)) {\n      // This component is still pending more data from the server, so we can't hydrate its\n      // content. We treat it as if this component suspended itself. It might seem as if\n      // we could just try to render it client-side instead. However, this will perform a\n      // lot of unnecessary work and is unlikely to complete since it often will suspend\n      // on missing data anyway. Additionally, the server might be able to render more\n      // than we can on the client yet. In that case we'd end up with more fallback states\n      // on the client than if we just leave it alone. If the server times out or errors\n      // these should update this boundary to the permanent Fallback state instead.\n      // Mark it as having captured (i.e. suspended).\n      workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n      workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n      var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n      registerSuspenseInstanceRetry(suspenseInstance, retry);\n      return null;\n    } else {\n      // This is the first attempt.\n      reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n      var primaryChildren = nextProps.children;\n      var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n\n      primaryChildFragment.flags |= Hydrating;\n      return primaryChildFragment;\n    }\n  } else {\n    // This is the second render pass. We already attempted to hydrated, but\n    // something either suspended or errored.\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during hydration. Try again without hydrating.\n      workInProgress.flags &= ~ForceClientRender;\n\n      var _capturedValue2 = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);\n    } else if (workInProgress.memoizedState !== null) {\n      // Something suspended and we should still be in dehydrated mode.\n      // Leave the existing child in place.\n      workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n      // but the normal suspense pass doesn't.\n\n      workInProgress.flags |= DidCapture;\n      return null;\n    } else {\n      // Suspended but we should no longer be in dehydrated mode.\n      // Therefore we now have to render the fallback.\n      var nextPrimaryChildren = nextProps.children;\n      var nextFallbackChildren = nextProps.fallback;\n      var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      var _primaryChildFragment4 = workInProgress.child;\n      _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    }\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  var node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  var row = firstChild;\n  var lastContentRow = null;\n\n  while (row !== null) {\n    var currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          default:\n            error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n\n            break;\n        }\n      } else {\n        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  {\n    var isAnArray = isArray(childSlot);\n    var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      var type = isAnArray ? 'array' : 'iterable';\n\n      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          var childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            var step = childrenIterator.next();\n            var _i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, _i)) {\n                return;\n              }\n\n              _i++;\n            }\n          }\n        } else {\n          error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  var renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var revealOrder = nextProps.revealOrder;\n  var tailMode = nextProps.tail;\n  var newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  var suspenseContext = suspenseStackCursor.current;\n  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          var lastContentRow = findLastContentRow(workInProgress.child);\n          var tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          var _tail = null;\n          var row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            var currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            var nextRow = row.sibling;\n            row.sibling = _tail;\n            _tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          _tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n  var newValue = newProps.value;\n\n  {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n\n        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  {\n    if (oldProps !== null) {\n      var oldValue = oldProps.value;\n\n      if (objectIs(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n\n          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    if (typeof render !== 'function') {\n      error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var newValue = readContext(context);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  var newChildren;\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (current !== null) {\n      // A lazy component only mounts if it suspended inside a non-\n      // concurrent tree, in an inconsistent state. We want to treat it like\n      // a new mount, even though an empty version of it already committed.\n      // Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    }\n  }\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning();\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  {\n    var returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      var prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  var updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      var root = workInProgress.stateNode;\n\n      resetHydrationState();\n      break;\n\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          pushContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        var newValue = workInProgress.memoizedProps.value;\n        var context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          var stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        var state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          if (state.dehydrated !== null) {\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n            // been unsuspended it has committed as a resolved Suspense component.\n            // If it needs to be retried, it should have work scheduled on it.\n\n            workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n            return null;\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          var primaryChildFragment = workInProgress.child;\n          var primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (didSuspendBefore) {\n          if (_hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n        if (_hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  }\n\n  if (current !== null) {\n    var oldProps = current.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n     workInProgress.type !== current.type )) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      var slotIndex = workInProgress.index;\n      var numberOfForks = getForksAtLevel();\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        var elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        var Component = workInProgress.type;\n        var unresolvedProps = workInProgress.pendingProps;\n        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        var _Component = workInProgress.type;\n        var _unresolvedProps = workInProgress.pendingProps;\n\n        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n\n        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        var type = workInProgress.type;\n        var _unresolvedProps2 = workInProgress.pendingProps;\n\n        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n\n        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        var _type2 = workInProgress.type;\n        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = _type2.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only\n              'prop', getComponentNameFromType(_type2));\n            }\n          }\n        }\n\n        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        var _Component2 = workInProgress.type;\n        var _unresolvedProps4 = workInProgress.pendingProps;\n\n        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n\n        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.flags |= Ref;\n\n  {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  var didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  var child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nvar appendAllChildren;\nvar updateHostContainer;\nvar updateHostComponent$1;\nvar updateHostText$1;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        var _instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance = cloneHiddenTextInstance(_instance, text, node);\n        }\n\n        appendInitialChild(parent, _instance);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        appendAllChildren(parent, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        var _instance2 = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, _instance2);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        appendAllChildrenToContainer(containerChildSet, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) ; else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var tailNode = renderState.tail;\n        var lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var _tailNode = renderState.tail;\n        var _lastTailNode = null;\n\n        while (_tailNode !== null) {\n          if (_tailNode.alternate !== null) {\n            _lastTailNode = _tailNode;\n          }\n\n          _tailNode = _tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (_lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          _lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  var newChildLanes = NoLanes;\n  var subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var actualDuration = completedWork.actualDuration;\n      var treeBaseDuration = completedWork.selfBaseDuration;\n      var child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n\n        actualDuration += child.actualDuration;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      var _child = completedWork.child;\n\n      while (_child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n        subtreeFlags |= _child.subtreeFlags;\n        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child.return = completedWork;\n        _child = _child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var _treeBaseDuration = completedWork.selfBaseDuration;\n      var _child2 = completedWork.child;\n\n      while (_child2 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n        subtreeFlags |= _child2.flags & StaticMask;\n        _treeBaseDuration += _child2.treeBaseDuration;\n        _child2 = _child2.sibling;\n      }\n\n      completedWork.treeBaseDuration = _treeBaseDuration;\n    } else {\n      var _child3 = completedWork.child;\n\n      while (_child3 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child3.return = completedWork;\n        _child3 = _child3.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nfunction completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n  if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n    warnIfUnhydratedTailNodes(workInProgress);\n    resetHydrationState();\n    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n    return false;\n  }\n\n  var wasHydrated = popHydrationState(workInProgress);\n\n  if (nextState !== null && nextState.dehydrated !== null) {\n    // We might be inside a hydration state the first time we're picking up this\n    // Suspense boundary, and also after we've reentered it for further hydration.\n    if (current === null) {\n      if (!wasHydrated) {\n        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n      }\n\n      prepareToHydrateHostSuspenseInstance(workInProgress);\n      bubbleProperties(workInProgress);\n\n      {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          var isTimedOutSuspense = nextState !== null;\n\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            var primaryChildFragment = workInProgress.child;\n\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    } else {\n      // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n      // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n      resetHydrationState();\n\n      if ((workInProgress.flags & DidCapture) === NoFlags) {\n        // This boundary did not suspend so it's now hydrated and unsuspended.\n        workInProgress.memoizedState = null;\n      } // If nothing suspended, we need to schedule an effect to mark this boundary\n      // as having hydrated so events know that they're free to be invoked.\n      // It's also a signal to replay events and the suspense callback.\n      // If something suspended, schedule an effect to attach retry listeners.\n      // So we might as well always mark this.\n\n\n      workInProgress.flags |= Update;\n      bubbleProperties(workInProgress);\n\n      {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          var _isTimedOutSuspense = nextState !== null;\n\n          if (_isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            var _primaryChildFragment = workInProgress.child;\n\n            if (_primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  } else {\n    // Successfully completed this tree. If this was a forced client render,\n    // there may have been recoverable errors during first hydration\n    // attempt. If so, add them to a queue so we can log them in the\n    // commit phase.\n    upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n\n    return true;\n  }\n}\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        var fiberRoot = workInProgress.stateNode;\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          var wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else {\n            if (current !== null) {\n              var prevState = current.memoizedState;\n\n              if ( // Check if this is a client root\n              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                // Schedule an effect to clear this container at the start of the\n                // next commit. This handles the case of React rendering into a\n                // container with previous children. It's also safe to do for\n                // updates too, because current.child would only be null if the\n                // previous render was null (so the container would already\n                // be empty).\n                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                // recoverable errors during first hydration attempt. If so, add\n                // them to a queue so we can log them in the commit phase.\n\n                upgradeHydrationErrorsToRecoverable();\n              }\n            }\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef$1(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          var _wasHydrated = popHydrationState(workInProgress);\n\n          if (_wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false);\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef$1(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        var newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText$1(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          var _rootContainerInstance = getRootHostContainer();\n\n          var _currentHostContext = getHostContext();\n\n          var _wasHydrated2 = popHydrationState(workInProgress);\n\n          if (_wasHydrated2) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n        // to its own fiber type so that we can add other kinds of hydration\n        // boundaries that aren't associated with a Suspense tree. In anticipation\n        // of such a refactor, all the hydration logic is contained in\n        // this branch.\n\n        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n          var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n\n          if (!fallthroughToNormalSuspensePath) {\n            if (workInProgress.flags & ShouldCapture) {\n              // Special case. There were remaining unhydrated nodes. We treat\n              // this as a mismatch. Revert to client rendering.\n              return workInProgress;\n            } else {\n              // Did not finish hydrating, either because this is the initial\n              // render or because something suspended.\n              return null;\n            }\n          } // Continue with the normal Suspense path.\n\n        }\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        var nextDidTimeout = nextState !== null;\n        var prevDidTimeout = current !== null && current.memoizedState !== null;\n        // a passive effect, which is when we process the transitions\n\n\n        if (nextDidTimeout !== prevDidTimeout) {\n          // an effect to toggle the subtree's visibility. When we switch from\n          // fallback -> primary, the inner Offscreen fiber schedules this effect\n          // as part of its normal complete phase. But when we switch from\n          // primary -> fallback, the inner Offscreen fiber does not have a complete\n          // phase. So we need to schedule its effect here.\n          //\n          // We also use this flag to connect/disconnect the effects, but the same\n          // logic applies: when re-connecting, the Offscreen fiber's complete\n          // phase will handle scheduling the effect. It's only when the fallback\n          // is active that we have to do anything special.\n\n\n          if (nextDidTimeout) {\n            var _offscreenFiber2 = workInProgress.child;\n            _offscreenFiber2.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n            // in the concurrent tree already suspended during this render.\n            // This is a known bug.\n\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n              // TODO: Move this back to throwException because this is too late\n              // if this is a large tree which is common for initial loads. We\n              // don't know if we should restart a render or not until we get\n              // this marker, and this is too late.\n              // If this render already had a ping or lower pri updates,\n              // and this is the first time we know we're going to suspend we\n              // should be able to immediately restart from within throwException.\n              var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n\n              if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                // If this was in an invisible tree or a new render, then showing\n                // this boundary is ok.\n                renderDidSuspend();\n              } else {\n                // Otherwise, we're going to have to hide content so we should\n                // suspend for longer if possible.\n                renderDidSuspendDelayIfPossible();\n              }\n            }\n          }\n        }\n\n        var wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              var primaryChildFragment = workInProgress.child;\n\n              if (primaryChildFragment !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        var _Component = workInProgress.type;\n\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        var renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              var row = workInProgress.child;\n\n              while (row !== null) {\n                var suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  var newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            var _suspended = findFirstSuspended(renderedTail);\n\n            if (_suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              var _newThenables = _suspended.updateQueue;\n\n              if (_newThenables !== null) {\n                workInProgress.updateQueue = _newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                  // We're done.\n                  bubbleProperties(workInProgress);\n                  return null;\n                }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            var previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          var next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          var suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popRenderLanes(workInProgress);\n        var _nextState = workInProgress.memoizedState;\n        var nextIsHidden = _nextState !== null;\n\n        if (current !== null) {\n          var _prevState = current.memoizedState;\n          var prevIsHidden = _prevState !== null;\n\n          if (prevIsHidden !== nextIsHidden && ( // LegacyHidden doesn't do any hiding \u2014 it only pre-renders.\n          !enableLegacyHidden )) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n            bubbleProperties(workInProgress);\n\n            if (supportsMutation) {\n              // Check if there was an insertion or update in the hidden subtree.\n              // If so, we need to hide those nodes in the commit phase, so\n              // schedule a visibility effect.\n              if ( workInProgress.subtreeFlags & (Placement | Update)) {\n                workInProgress.flags |= Visibility;\n              }\n            }\n          }\n        }\n        return null;\n      }\n\n    case CacheComponent:\n      {\n\n        return null;\n      }\n\n    case TracingMarkerComponent:\n      {\n\n        return null;\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nfunction unwindWork(current, workInProgress, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        var flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case HostRoot:\n      {\n        var root = workInProgress.stateNode;\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n        var _flags = workInProgress.flags;\n\n        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n          // There was an error during render that wasn't captured by a suspense\n          // boundary. Do a second pass on the root to unmount the children.\n          workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        } // We unwound to the root without completing it. Exit.\n\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        // TODO: popHydrationState\n        popHostContext(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var suspenseState = workInProgress.memoizedState;\n\n        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n          if (workInProgress.alternate === null) {\n            throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n          }\n\n          resetHydrationState();\n        }\n\n        var _flags2 = workInProgress.flags;\n\n        if (_flags2 & ShouldCapture) {\n          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n        // caught by a nested boundary. If not, it should bubble through.\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n\n    case ContextProvider:\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(workInProgress);\n      return null;\n\n    case CacheComponent:\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(current, interruptedWork, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        var childContextTypes = interruptedWork.type.childContextTypes;\n\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        var root = interruptedWork.stateNode;\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        resetWorkInProgressVersions();\n        break;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n\n    case SuspenseComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case SuspenseListComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case ContextProvider:\n      var context = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(interruptedWork);\n      break;\n  }\n}\n\nfunction invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n}\n\nvar invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebook/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      if (typeof document === 'undefined' || document === null) {\n        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');\n      }\n\n      var evt = document.createEvent('Event');\n      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n\n      var didError = true; // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n\n      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\n      // dispatching: https://github.com/facebook/react/issues/13688\n\n      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\n\n      function restoreAfterDispatch() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n      } // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n\n\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      function callCallback() {\n        didCall = true;\n        restoreAfterDispatch();\n        func.apply(context, funcArgs);\n        didError = false;\n      } // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n\n\n      var error; // Use this to track whether the error event is ever called.\n\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {// Ignore.\n            }\n          }\n        }\n      } // Create a fake event type.\n\n\n      var evtType = \"react-\" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (windowEventDescriptor) {\n        Object.defineProperty(window, 'event', windowEventDescriptor);\n      }\n\n      if (didCall && didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\n        }\n\n        this.onError(error);\n      } // Remove our event listeners\n\n\n      window.removeEventListener('error', handleWindowError);\n\n      if (!didCall) {\n        // Something went really wrong, and our event was not dispatched.\n        // https://github.com/facebook/react/issues/16734\n        // https://github.com/facebook/react/issues/16585\n        // Fall back to the production implementation.\n        restoreAfterDispatch();\n        return invokeGuardedCallbackProd.apply(this, arguments);\n      }\n    };\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\nvar hasError = false;\nvar caughtError = null; // Used by event system to capture/rethrow the first error.\nvar reporter = {\n  onError: function (error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\nfunction hasCaughtError() {\n  return hasError;\n}\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\nvar offscreenSubtreeIsHidden = false;\nvar offscreenSubtreeWasHidden = false;\nvar PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nvar nextEffect = null; // Used for Profiling builds to track updaters.\n\nvar inProgressLanes = null;\nvar inProgressRoot = null;\nfunction reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  {\n    invokeGuardedCallback(null, function () {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if ( current.mode & ProfileMode) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n  try {\n    commitHookEffectListMount(Layout, current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      var retVal;\n\n      try {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nvar focusedInstanceHandle = null;\nvar shouldFireAfterActiveInstanceBlur = false;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  var shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n\n    var child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    setCurrentFiber(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  var current = finishedWork.alternate;\n  var flags = finishedWork.flags;\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentFiber(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          break;\n        }\n\n      case ClassComponent:\n        {\n          if (current !== null) {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            var instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n\n                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          if (supportsMutation) {\n            var root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n\n      default:\n        {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        var destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          {\n            if ((flags & Insertion) !== NoFlags$1) {\n              setIsRunningInsertionEffect(true);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          {\n            if ((flags & Insertion) !== NoFlags$1) {\n              setIsRunningInsertionEffect(false);\n            }\n          }\n\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        var create = effect.create;\n\n        {\n          if ((flags & Insertion) !== NoFlags$1) {\n            setIsRunningInsertionEffect(true);\n          }\n        }\n\n        effect.destroy = create();\n\n        {\n          if ((flags & Insertion) !== NoFlags$1) {\n            setIsRunningInsertionEffect(false);\n          }\n        }\n\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        {\n          var destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            var hookName = void 0;\n\n            if ((effect.tag & Layout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & Insertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            var addendum = void 0;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n            var _finishedWork$memoize = finishedWork.memoizedProps,\n                id = _finishedWork$memoize.id,\n                onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            var commitTime = getCommitTime();\n            var phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            var parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          if ( !offscreenSubtreeWasHidden) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if ( finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                commitHookEffectListMount(Layout | HasEffect, finishedWork);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(Layout | HasEffect, finishedWork);\n            }\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n\n          if (finishedWork.flags & Update) {\n            if (!offscreenSubtreeWasHidden) {\n              if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidMount();\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidMount();\n                }\n              } else {\n                var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                }\n              }\n            }\n          } // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n\n\n          var updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            } // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          var _updateQueue = finishedWork.updateQueue;\n\n          if (_updateQueue !== null) {\n            var _instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  _instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  _instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            commitUpdateQueue(finishedWork, _updateQueue, _instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n\n          if (current === null && finishedWork.flags & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          break;\n        }\n\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          break;\n        }\n\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          break;\n        }\n\n      case Profiler:\n        {\n          {\n            var _finishedWork$memoize2 = finishedWork.memoizedProps,\n                onCommit = _finishedWork$memoize2.onCommit,\n                onRender = _finishedWork$memoize2.onRender;\n            var effectDuration = finishedWork.stateNode.effectDuration;\n            var commitTime = getCommitTime();\n            var phase = current === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onRender === 'function') {\n              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n            }\n\n            {\n              if (typeof onCommit === 'function') {\n                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n              // because the effect is also where times bubble to parent Profilers.\n\n\n              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n              var parentFiber = finishedWork.return;\n\n              outer: while (parentFiber !== null) {\n                switch (parentFiber.tag) {\n                  case HostRoot:\n                    var root = parentFiber.stateNode;\n                    root.effectDuration += effectDuration;\n                    break outer;\n\n                  case Profiler:\n                    var parentStateNode = parentFiber.stateNode;\n                    parentStateNode.effectDuration += effectDuration;\n                    break outer;\n                }\n\n                parentFiber = parentFiber.return;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n          break;\n        }\n\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n      case TracingMarkerComponent:\n        {\n          break;\n        }\n\n      default:\n        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  if ( !offscreenSubtreeWasHidden) {\n    {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( node.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n          } finally {\n            recordLayoutEffectDuration(node);\n          }\n        } else {\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        var instance = node.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          safelyCallComponentDidMount(node, node.return, instance);\n        }\n\n        safelyAttachRef(node, node.return);\n        break;\n      }\n\n    case HostComponent:\n      {\n        safelyAttachRef(node, node.return);\n        break;\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  var hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n\n          try {\n            var instance = node.stateNode;\n\n            if (isHidden) {\n              hideInstance(instance);\n            } else {\n              unhideInstance(node.stateNode, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          try {\n            var _instance3 = node.stateNode;\n\n            if (isHidden) {\n              hideTextInstance(_instance3);\n            } else {\n              unhideTextInstance(_instance3, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n    if (typeof ref === 'function') {\n      var retVal;\n\n      if ( finishedWork.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n        }\n      }\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      var hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical \u2014 it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    {\n      fiber._debugOwner = null;\n    }\n\n    {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current.stateNode;\n  var containerInfo = portal.containerInfo;\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  var node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      {\n        var parent = parentFiber.stateNode;\n\n        if (parentFiber.flags & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.flags &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        var _parent = parentFiber.stateNode.containerInfo;\n\n        var _before = getHostSibling(finishedWork);\n\n        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n} // These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\n\n\nvar hostParent = null;\nvar hostParentIsContainer = false;\n\nfunction commitDeletionEffects(root, returnFiber, deletedFiber) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was deleted but we need to recurse down its\n    // children to find all the terminal nodes.\n    // Recursively delete all host nodes from the parent, detach refs, clean\n    // up mounted layout effects, and call componentWillUnmount.\n    // We only need to remove the topmost host child in each branch. But then we\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n    // could split this into two separate traversals functions, where the second\n    // one doesn't include any removeChild logic. This is maybe the same\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n    // the layout phase is refactored to use recursion).\n    // Before starting, find the nearest host parent on the stack so we know\n    // which instance/container to remove the children from.\n    // TODO: Instead of searching up the fiber return path on every deletion, we\n    // can track the nearest host component on the JS stack as we traverse the\n    // tree during the commit phase. This would make insertions faster, too.\n    var parent = returnFiber;\n\n    findParent: while (parent !== null) {\n      switch (parent.tag) {\n        case HostComponent:\n          {\n            hostParent = parent.stateNode;\n            hostParentIsContainer = false;\n            break findParent;\n          }\n\n        case HostRoot:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n\n        case HostPortal:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n      }\n\n      parent = parent.return;\n    }\n\n    if (hostParent === null) {\n      throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n    }\n\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n    hostParent = null;\n    hostParentIsContainer = false;\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n  }\n\n  detachFiberMutation(deletedFiber);\n}\n\nfunction recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n  // TODO: Use a static flag to skip trees that don't have unmount effects\n  var child = parent.child;\n\n  while (child !== null) {\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n    child = child.sibling;\n  }\n}\n\nfunction commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n  onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n  // into their subtree. There are simpler cases in the inner switch\n  // that don't modify the stack.\n\n  switch (deletedFiber.tag) {\n    case HostComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostText:\n      {\n        // We only need to remove the nearest host child. Set the host parent\n        // to `null` on the stack to indicate that nested children don't\n        // need to be removed.\n        if (supportsMutation) {\n          var prevHostParent = hostParent;\n          var prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n\n          if (hostParent !== null) {\n            // Now that all the child effects have unmounted, we can remove the\n            // node from the tree.\n            if (hostParentIsContainer) {\n              removeChildFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              removeChild(hostParent, deletedFiber.stateNode);\n            }\n          }\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        // Delete the dehydrated suspense boundary and all of its content.\n\n\n        if (supportsMutation) {\n          if (hostParent !== null) {\n            if (hostParentIsContainer) {\n              clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        if (supportsMutation) {\n          // When we go into a portal, it becomes the parent to remove from.\n          var _prevHostParent = hostParent;\n          var _prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = deletedFiber.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = _prevHostParent;\n          hostParentIsContainer = _prevHostParentIsContainer;\n        } else {\n          emptyPortalContainer(deletedFiber);\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          var updateQueue = deletedFiber.updateQueue;\n\n          if (updateQueue !== null) {\n            var lastEffect = updateQueue.lastEffect;\n\n            if (lastEffect !== null) {\n              var firstEffect = lastEffect.next;\n              var effect = firstEffect;\n\n              do {\n                var _effect = effect,\n                    destroy = _effect.destroy,\n                    tag = _effect.tag;\n\n                if (destroy !== undefined) {\n                  if ((tag & Insertion) !== NoFlags$1) {\n                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                  } else if ((tag & Layout) !== NoFlags$1) {\n                    {\n                      markComponentLayoutEffectUnmountStarted(deletedFiber);\n                    }\n\n                    if ( deletedFiber.mode & ProfileMode) {\n                      startLayoutEffectTimer();\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                      recordLayoutEffectDuration(deletedFiber);\n                    } else {\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                    }\n\n                    {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            }\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          var instance = deletedFiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ScopeComponent:\n      {\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        if ( // TODO: Remove this dead flag\n         deletedFiber.mode & ConcurrentMode) {\n          // If this offscreen component is hidden, we already unmounted it. Before\n          // deleting the children, track that it's already unmounted so that we\n          // don't attempt to unmount the effects again.\n          // TODO: If the tree is hidden, in most cases we should be able to skip\n          // over the nested children entirely. An exception is we haven't yet found\n          // the topmost host node to delete, which we already track on the stack.\n          // But the other case is portals, which need to be detached no matter how\n          // deeply they are nested. We should use a subtree flag to track whether a\n          // subtree includes a nested portal.\n          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n  }\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  var newState = finishedWork.memoizedState;\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  var newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    var current = finishedWork.alternate;\n\n    if (current !== null) {\n      var prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        var suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  var wakeables = finishedWork.updateQueue;\n\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    var retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    wakeables.forEach(function (wakeable) {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n} // This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root, finishedWork, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  setCurrentFiber(finishedWork);\n  commitMutationEffectsOnFiber(finishedWork, root);\n  setCurrentFiber(finishedWork);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects hae fired.\n  var deletions = parentFiber.deletions;\n\n  if (deletions !== null) {\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i];\n\n      try {\n        commitDeletionEffects(root, parentFiber, childToDelete);\n      } catch (error) {\n        captureCommitPhaseError(childToDelete, parentFiber, error);\n      }\n    }\n  }\n\n  var prevDebugFiber = getCurrentFiber();\n\n  if (parentFiber.subtreeFlags & MutationMask) {\n    var child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentFiber(child);\n      commitMutationEffectsOnFiber(child, root);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentFiber(prevDebugFiber);\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n  var current = finishedWork.alternate;\n  var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n  // because the fiber tag is more specific. An exception is any flag related\n  // to reconcilation, because those can be set on all fiber types.\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          try {\n            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n            commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          } // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n\n\n          if ( finishedWork.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n\n            recordLayoutEffectDuration(finishedWork);\n          } else {\n            try {\n              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (supportsMutation) {\n          // TODO: ContentReset gets cleared by the children during the commit\n          // phase. This is a refactor hazard because it means we must read\n          // flags the flags after `commitReconciliationEffects` has already run;\n          // the order matters. We should refactor so that ContentReset does not\n          // rely on mutating the flag during commit. Like by setting a flag\n          // during the render phase instead.\n          if (finishedWork.flags & ContentReset) {\n            var instance = finishedWork.stateNode;\n\n            try {\n              resetTextContent(instance);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n\n          if (flags & Update) {\n            var _instance4 = finishedWork.stateNode;\n\n            if (_instance4 != null) {\n              // Commit the work prepared earlier.\n              var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldProps = current !== null ? current.memoizedProps : newProps;\n              var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n              var updatePayload = finishedWork.updateQueue;\n              finishedWork.updateQueue = null;\n\n              if (updatePayload !== null) {\n                try {\n                  commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation) {\n            if (finishedWork.stateNode === null) {\n              throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            }\n\n            var textInstance = finishedWork.stateNode;\n            var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n\n            var oldText = current !== null ? current.memoizedProps : newText;\n\n            try {\n              commitTextUpdate(textInstance, oldText, newText);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation && supportsHydration) {\n            if (current !== null) {\n              var prevRootState = current.memoizedState;\n\n              if (prevRootState.isDehydrated) {\n                try {\n                  commitHydratedContainer(root.containerInfo);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n\n          if (supportsPersistence) {\n            var containerInfo = root.containerInfo;\n            var pendingChildren = root.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsPersistence) {\n            var portal = finishedWork.stateNode;\n            var _containerInfo = portal.containerInfo;\n            var _pendingChildren = portal.pendingChildren;\n\n            try {\n              replaceContainerChildren(_containerInfo, _pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n        var offscreenFiber = finishedWork.child;\n\n        if (offscreenFiber.flags & Visibility) {\n          var offscreenInstance = offscreenFiber.stateNode;\n          var newState = offscreenFiber.memoizedState;\n          var isHidden = newState !== null; // Track the current state on the Offscreen instance so we can\n          // read it during an event\n\n          offscreenInstance.isHidden = isHidden;\n\n          if (isHidden) {\n            var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n        }\n\n        if (flags & Update) {\n          try {\n            commitSuspenseCallback(finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        var _wasHidden = current !== null && current.memoizedState !== null;\n\n        if ( // TODO: Remove this dead flag\n         finishedWork.mode & ConcurrentMode) {\n          // Before committing the children, track on the stack whether this\n          // offscreen subtree was already hidden, so that we don't unmount the\n          // effects again.\n          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n          recursivelyTraverseMutationEffects(root, finishedWork);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseMutationEffects(root, finishedWork);\n        }\n\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Visibility) {\n          var _offscreenInstance = finishedWork.stateNode;\n          var _newState = finishedWork.memoizedState;\n\n          var _isHidden = _newState !== null;\n\n          var offscreenBoundary = finishedWork; // Track the current state on the Offscreen instance so we can\n          // read it during an event\n\n          _offscreenInstance.isHidden = _isHidden;\n\n          {\n            if (_isHidden) {\n              if (!_wasHidden) {\n                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                  nextEffect = offscreenBoundary;\n                  var offscreenChild = offscreenBoundary.child;\n\n                  while (offscreenChild !== null) {\n                    nextEffect = offscreenChild;\n                    disappearLayoutEffects_begin(offscreenChild);\n                    offscreenChild = offscreenChild.sibling;\n                  }\n                }\n              }\n            }\n          }\n\n          if (supportsMutation) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n\n        return;\n      }\n\n    default:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n        return;\n      }\n  }\n}\n\nfunction commitReconciliationEffects(finishedWork) {\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\n  // type. They needs to happen after the children effects have fired, but\n  // before the effects on this fiber have fired.\n  var flags = finishedWork.flags;\n\n  if (flags & Placement) {\n    try {\n      commitPlacement(finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    } // Clear the \"placement\" from effect tag so that we know that this is\n    // inserted, before any life-cycles like componentDidMount gets called.\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n    // and isMounted is deprecated anyway so we should be able to kill this.\n\n\n    finishedWork.flags &= ~Placement;\n  }\n\n  if (flags & Hydrating) {\n    finishedWork.flags &= ~Hydrating;\n  }\n}\n\nfunction commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ( fiber.tag === OffscreenComponent && isModernRoot) {\n      // Keep track of the current Offscreen stack's state.\n      var isHidden = fiber.memoizedState !== null;\n      var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        var current = fiber.alternate;\n        var wasHidden = current !== null && current.memoizedState !== null;\n        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        var child = firstChild;\n\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n          root, committedLanes);\n          child = child.sibling;\n        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      var current = fiber.alternate;\n      setCurrentFiber(fiber);\n\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ( fiber.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout, fiber, fiber.return);\n            } finally {\n              recordLayoutEffectDuration(fiber);\n            }\n          } else {\n            commitHookEffectListUnmount(Layout, fiber, fiber.return);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          // TODO (Offscreen) Check: flags & RefStatic\n          safelyDetachRef(fiber, fiber.return);\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          safelyDetachRef(fiber, fiber.return);\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          // Check if this is a\n          var isHidden = fiber.memoizedState !== null;\n\n          if (isHidden) {\n            // Nested Offscreen tree is already hidden. Don't disappear\n            // its effects.\n            disappearLayoutEffects_complete(subtreeRoot);\n            continue;\n          }\n\n          break;\n        }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      var isHidden = fiber.memoizedState !== null;\n\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n    setCurrentFiber(fiber);\n\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n\n      try {\n        commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n          } finally {\n            recordPassiveEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffects(firstChild) {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      var deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (var i = 0; i < deletions.length; i++) {\n          var fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n        }\n\n        {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          var previousFiber = fiber.alternate;\n\n          if (previousFiber !== null) {\n            var detachedChild = previousFiber.child;\n\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n\n              do {\n                var detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentFiber();\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n          recordPassiveEffectDuration(finishedWork);\n        } else {\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentFiber(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentFiber();\n    var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var sibling = fiber.sibling;\n    var returnFiber = fiber.return;\n\n    {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      sibling.return = returnFiber;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( current.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n          recordPassiveEffectDuration(current);\n        } else {\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n        }\n\n        break;\n      }\n  }\n} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Layout | HasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nvar COMPONENT_TYPE = 0;\nvar HAS_PSEUDO_CLASS_TYPE = 1;\nvar ROLE_TYPE = 2;\nvar TEST_NAME_TYPE = 3;\nvar TEXT_TYPE = 4;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\nfunction createComponentSelector(component) {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component\n  };\n}\nfunction createHasPseudoClassSelector(selectors) {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors\n  };\n}\nfunction createRoleSelector(role) {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role\n  };\n}\nfunction createTextSelector(text) {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text\n  };\n}\nfunction createTestNameSelector(id) {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot) {\n  var maybeFiber = getInstanceFromNode(hostRoot);\n\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n    }\n\n    return maybeFiber;\n  } else {\n    var fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error('Could not find React container within specified host subtree.');\n    } // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n    return fiberRoot.stateNode.current;\n  }\n}\n\nfunction matchSelector(fiber, selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n\n      break;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(fiber, selector.value);\n\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        var node = fiber.stateNode;\n\n        if (matchAccessibilityRole(node, selector.value)) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        var textContent = getTextContent(fiber);\n\n        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        var dataTestID = fiber.memoizedProps['data-testname'];\n\n        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n          return true;\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return \"<\" + displayName + \">\";\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return \":has(\" + (selectorToString(selector) || '') + \")\";\n\n    case ROLE_TYPE:\n      return \"[role=\\\"\" + selector.value + \"\\\"]\";\n\n    case TEXT_TYPE:\n      return \"\\\"\" + selector.value + \"\\\"\";\n\n    case TEST_NAME_TYPE:\n      return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root, selectors) {\n  var matchingFibers = [];\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n} // Same as findPaths but with eager bailout on first match\n\n\nfunction hasMatchingPaths(root, selectors) {\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction findAllNodes(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var instanceRoots = [];\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var node = stack[index++];\n\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n\n      instanceRoots.push(node.stateNode);\n    } else {\n      var child = node.child;\n\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\nfunction getFindAllNodesFailureDescription(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var maxSelectorIndex = 0;\n  var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    var unmatchedNames = [];\n\n    for (var i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n  }\n\n  return null;\n}\nfunction findBoundingRects(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n  var boundingRects = [];\n\n  for (var i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (var _i = boundingRects.length - 1; _i > 0; _i--) {\n    var targetRect = boundingRects[_i];\n    var targetLeft = targetRect.x;\n    var targetRight = targetLeft + targetRect.width;\n    var targetTop = targetRect.y;\n    var targetBottom = targetTop + targetRect.height;\n\n    for (var j = _i - 1; j >= 0; j--) {\n      if (_i !== j) {\n        var otherRect = boundingRects[j];\n        var otherLeft = otherRect.x;\n        var otherRight = otherLeft + otherRect.width;\n        var otherTop = otherRect.y;\n        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\nfunction focusWithin(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n\n    if (fiber.tag === HostComponent) {\n      var node = fiber.stateNode;\n\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n\n    var child = fiber.child;\n\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\nvar commitHooks = [];\nfunction onCommitRoot$1() {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(function (commitHook) {\n      return commitHook();\n    });\n  }\n}\nfunction observeVisibleRects(hostRoot, selectors, callback, options) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n\n  var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options),\n      disconnect = _setupIntersectionObs.disconnect,\n      observe = _setupIntersectionObs.observe,\n      unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n\n\n  var commitHook = function () {\n    var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n    instanceRoots.forEach(function (target) {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n    nextInstanceRoots.forEach(function (target) {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n  return {\n    disconnect: function () {\n      // Stop listening for React mutations:\n      var index = commitHooks.indexOf(commitHook);\n\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      } // Disconnect the host observer:\n\n\n      disconnect();\n    }\n  };\n}\n\nvar ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\nfunction isLegacyActEnvironment(fiber) {\n  {\n    // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n    // act environment whenever `jest` is defined, but you can still turn off\n    // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n    // to false.\n    var isReactActEnvironmentGlobal = // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n\n    var jestIsDefined = typeof jest !== 'undefined';\n    return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n  }\n}\nfunction isConcurrentActEnvironment() {\n  {\n    var isReactActEnvironmentGlobal = // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n\n    if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n      // TODO: Include link to relevant documentation page.\n      error('The current testing environment is not configured to support ' + 'act(...)');\n    }\n\n    return isReactActEnvironmentGlobal;\n  }\n}\n\nvar ceil = Math.ceil;\nvar ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,\n    ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,\n    ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\nvar NoContext =\n/*             */\n0;\nvar BatchedContext =\n/*               */\n1;\nvar RenderContext =\n/*                */\n2;\nvar CommitContext =\n/*                */\n4;\nvar RootInProgress = 0;\nvar RootFatalErrored = 1;\nvar RootErrored = 2;\nvar RootSuspended = 3;\nvar RootSuspendedWithDelay = 4;\nvar RootCompleted = 5;\nvar RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\nvar executionContext = NoContext; // The root we're working on\n\nvar workInProgressRoot = null; // The fiber we're working on\n\nvar workInProgress = null; // The lanes we're rendering\n\nvar workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\nvar subtreeRenderLanes = NoLanes;\nvar subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\nvar workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\nvar workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\n\nvar workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nvar workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nvar workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nvar workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\nvar workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\n\nvar workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nvar globalMostRecentFallbackTime = 0;\nvar FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nvar workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nvar RENDER_TIMEOUT_MS = 500;\nvar workInProgressTransitions = null;\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nfunction getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nvar hasUncaughtError = false;\nvar firstUncaughtError = null;\nvar legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects = false;\nvar rootWithPendingPassiveEffects = null;\nvar pendingPassiveEffectsLanes = NoLanes;\nvar pendingPassiveProfilerEffects = [];\nvar pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar rootWithNestedUpdates = null;\nvar isFlushingPassiveEffects = false;\nvar didScheduleUpdateDuringPassiveEffects = false;\nvar NESTED_PASSIVE_UPDATE_LIMIT = 50;\nvar nestedPassiveUpdateCount = 0;\nvar rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nvar currentEventTime = NoTimestamp;\nvar currentEventTransitionLane = NoLanes;\nvar isRunningInsertionEffect = false;\nfunction getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nfunction requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now();\n  return currentEventTime;\n}\nfunction requestUpdateLane(fiber) {\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if ( (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  var isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if ( ReactCurrentBatchConfig$2.transition !== null) {\n      var transition = ReactCurrentBatchConfig$2.transition;\n\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" \u2014 a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n\nfunction scheduleUpdateOnFiber(root, fiber, lane, eventTime) {\n  checkForNestedUpdates();\n\n  {\n    if (isRunningInsertionEffect) {\n      error('useInsertionEffect must not schedule updates.');\n    }\n  }\n\n  {\n    if (isFlushingPassiveEffects) {\n      didScheduleUpdateDuringPassiveEffects = true;\n    }\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if ( (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended$1(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nfunction scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  var current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n}\nfunction isUnsafeClassRenderPhaseUpdate(fiber) {\n  // Check if this is a render phase update. Only called by class components,\n  // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n  return (// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n    // decided not to enable it.\n     (executionContext & RenderContext) !== NoContext\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback$1(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  var existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !( ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n        error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback$1(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  var newCallbackNode;\n\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if ( ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n      }\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if ( ReactCurrentActQueue$1.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(function () {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n            // Note that this would still prematurely flush the callbacks\n            // if this happens outside render or commit phase (e.g. in an event).\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    var schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediatePriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdlePriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n    }\n\n    newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  var originalCallbackNode = root.callbackNode;\n  var didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && ( !didTimeout);\n  var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      var fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended$1(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      //\n      // This should only happen during a concurrent render, not a discrete or\n      // synchronous update. We should have already checked for this when we\n      // unwound the stack.\n      markRootSuspended$1(root, lanes);\n    } else {\n      // The render completed.\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      var renderWasConcurrent = !includesBlockingLane(root, lanes);\n      var finishedWork = root.current.alternate;\n\n      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n        if (exitStatus === RootErrored) {\n          var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n          if (_errorRetryLanes !== NoLanes) {\n            lanes = _errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n\n        if (exitStatus === RootFatalErrored) {\n          var _fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended$1(root, lanes);\n          ensureRootIsScheduled(root, now());\n          throw _fatalError;\n        }\n      } // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  // Before rendering again, save the errors from the previous attempt.\n  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n  if (isRootDehydrated(root)) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n\n    {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  var exitStatus = renderRootSync(root, errorRetryLanes);\n\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n    // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n    var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  }\n\n  return exitStatus;\n}\n\nfunction queueRecoverableErrors(errors) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            var nextLanes = getNextLanes(root, NoLanes);\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            var suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              var eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended$1(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          var eventTimeMs = mostRecentEventTime;\n          var timeElapsedMs = now() - eventTimeMs;\n\n          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n\n          if (_msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  var node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      var updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        var checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (var i = 0; i < checks.length; i++) {\n            var check = checks[i];\n            var getSnapshot = check.getSnapshot;\n            var renderedValue = check.value;\n\n            try {\n              if (!objectIs(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    var child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended$1(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n  markRootSuspended(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n  var lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  var exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    var fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended$1(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    throw new Error('Root did not complete. This is a bug in React.');\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  var finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now());\n  return null;\n}\n\nfunction flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction deferredUpdates(fn) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  }\n}\nfunction batchedUpdates(fn, a) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nfunction discreteUpdates(fn, a, b, c, d) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushPassiveEffects();\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return  (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nfunction flushControlled(fn) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction pushRenderLanes(fiber, lanes) {\n  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n}\nfunction popRenderLanes(fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  pop(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  var timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    var interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      var current = interruptedWork.alternate;\n      unwindInterruptedWork(current, interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  var rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  finishQueueingConcurrentUpdates();\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    var erroredWork = workInProgress;\n\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n\n      ReactCurrentOwner$2.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n          var wakeable = thrownValue;\n          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n        } else {\n          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n      }\n\n      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  var prevDispatcher = ReactCurrentDispatcher$2.current;\n  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher$2.current = prevDispatcher;\n}\n\nfunction markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nfunction markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nfunction renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nfunction renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nfunction renderDidError(error) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nfunction renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n}\n\nfunction renderRootSync(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes();\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes();\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    {\n      markRenderYielded();\n    }\n\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  var current = unitOfWork.alternate;\n  setCurrentFiber(unitOfWork);\n  var next;\n\n  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentFiber();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner$2.current = null;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  var completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    var current = completedWork.alternate;\n    var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentFiber(completedWork);\n      var next = void 0;\n\n      if ( (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentFiber();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n\n\n      if (_next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.flags &= HostEffectMask;\n        workInProgress = _next;\n        return;\n      }\n\n      if ( (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        var actualDuration = completedWork.actualDuration;\n        var child = completedWork.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    var siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root, recoverableErrors, transitions) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  var previousUpdateLanePriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  var finishedWork = root.finishedWork;\n  var lanes = root.finishedLanes;\n\n  {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n\n    {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    {\n      if (lanes === NoLanes) {\n        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      // to store it in pendingPassiveTransitions until they get processed\n      // We need to pass this through as an argument to commitRoot\n      // because workInProgressTransitions might have changed between\n      // the previous render and commit if we throttle the commit\n      // with setTimeout\n\n      pendingPassiveTransitions = transitions;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    ReactCurrentBatchConfig$2.transition = null;\n    var previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    var prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n\n    {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    {\n      markLayoutEffectsStopped();\n    }\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    {\n      recordCommitTime();\n    }\n  }\n\n  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n\n    {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n    }\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed \u2014 that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n\n  {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  {\n    onCommitRoot$1();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    var onRecoverableError = root.onRecoverableError;\n\n    for (var i = 0; i < recoverableErrors.length; i++) {\n      var recoverableError = recoverableErrors[i];\n      var componentStack = recoverableError.stack;\n      var digest = recoverableError.digest;\n      onRecoverableError(recoverableError.value, {\n        componentStack: componentStack,\n        digest: digest\n      });\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    var error$1 = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error$1;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSomeLane(remainingLanes, SyncLane)) {\n    {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    var previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig$2.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n    }\n  }\n\n  return false;\n}\nfunction enqueuePendingPassiveProfilerEffect(fiber) {\n  {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  } // Cache and clear the transitions flag\n\n\n  var transitions = pendingPassiveTransitions;\n  pendingPassiveTransitions = null;\n  var root = rootWithPendingPassiveEffects;\n  var lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  {\n    isFlushingPassiveEffects = true;\n    didScheduleUpdateDuringPassiveEffects = false;\n  }\n\n  {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n\n  {\n    var profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (var i = 0; i < profilerEffects.length; i++) {\n      var _fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, _fiber);\n    }\n  }\n\n  {\n    markPassiveEffectsStopped();\n  }\n\n  {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks();\n\n  {\n    // If additional passive effects were scheduled, increment a counter. If this\n    // exceeds the limit, we'll fire a warning.\n    if (didScheduleUpdateDuringPassiveEffects) {\n      if (root === rootWithPassiveNestedUpdates) {\n        nestedPassiveUpdateCount++;\n      } else {\n        nestedPassiveUpdateCount = 0;\n        rootWithPassiveNestedUpdates = root;\n      }\n    } else {\n      nestedPassiveUpdateCount = 0;\n    }\n\n    isFlushingPassiveEffects = false;\n    didScheduleUpdateDuringPassiveEffects = false;\n  } // TODO: Move to commitPassiveMountEffects\n\n\n  onPostCommitRoot(root);\n\n  {\n    var stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nvar onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  var root = enqueueUpdate(rootFiber, update, SyncLane);\n  var eventTime = requestEventTime();\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n  {\n    reportUncaughtErrorInDEV(error$1);\n    setIsRunningInsertionEffect(false);\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n    return;\n  }\n\n  var fiber = null;\n\n  {\n    fiber = nearestMountedAncestor;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      var ctor = fiber.type;\n      var instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        var root = enqueueUpdate(fiber, update, SyncLane);\n        var eventTime = requestEventTime();\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n  }\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  var eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  var eventTime = requestEventTime();\n  var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState;\n  var retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = NoLane; // Default\n\n  var retryCache;\n\n  switch (boundaryFiber.tag) {\n    case SuspenseComponent:\n      retryCache = boundaryFiber.stateNode;\n      var suspenseState = boundaryFiber.memoizedState;\n\n      if (suspenseState !== null) {\n        retryLane = suspenseState.retryLane;\n      }\n\n      break;\n\n    case SuspenseListComponent:\n      retryCache = boundaryFiber.stateNode;\n      break;\n\n    default:\n      throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n\n      error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n    setCurrentFiber(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    var current = firstChild;\n    var subtreeRoot = null;\n\n    while (current !== null) {\n      var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nvar didWarnStateUpdateForNotYetMountedComponent = null;\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    var tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    var previousFiber = current;\n\n    try {\n      setCurrentFiber(fiber);\n\n      error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentFiber(fiber);\n      } else {\n        resetCurrentFiber();\n      }\n    }\n  }\n}\nvar beginWork$1;\n\n{\n  var dummyFiber = null;\n\n  beginWork$1 = function (current, unitOfWork, lanes) {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return beginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises.\n        // Don't replay errors if we are hydrating and have already suspended or handled an error\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if ( unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        var replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n}\n\nvar didWarnAboutUpdateInRender = false;\nvar didWarnAboutUpdateInRenderForAnotherComponent;\n\n{\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  {\n    if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            var dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction restorePendingUpdaters(root, lanes) {\n  {\n    if (isDevToolsPresent) {\n      var memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(function (schedulingFiber) {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nvar fakeActCallbackNode = {};\n\nfunction scheduleCallback$1(priorityLevel, callback) {\n  {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    var actQueue = ReactCurrentActQueue$1.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return scheduleCallback(priorityLevel, callback);\n    }\n  }\n}\n\nfunction cancelCallback$1(callbackNode) {\n  if ( callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return  ReactCurrentActQueue$1.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue$1.current === null) {\n      var previousFiber = current;\n\n      try {\n        setCurrentFiber(fiber);\n\n        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentFiber(fiber);\n        } else {\n          resetCurrentFiber();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n      error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}\n\nfunction setIsRunningInsertionEffect(isRunning) {\n  {\n    isRunningInsertionEffect = isRunning;\n  }\n}\n\n/* eslint-disable react-internal/prod-error-codes */\nvar resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\nvar failedBoundaries = null;\nvar setRefreshHandler = function (handler) {\n  {\n    resolveFamily = handler;\n  }\n};\nfunction resolveFunctionForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction resolveClassForHotReloading(type) {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\nfunction resolveForwardRefForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (type !== null && type !== undefined && typeof type.render === 'function') {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        var currentRender = resolveFunctionForHotReloading(type.render);\n\n        if (type.render !== currentRender) {\n          var syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender\n          };\n\n          if (type.displayName !== undefined) {\n            syntheticType.displayName = type.displayName;\n          }\n\n          return syntheticType;\n        }\n      }\n\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction isCompatibleFamilyForHotReloading(fiber, element) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    var prevType = fiber.elementType;\n    var nextType = element.type; // If we got here, we know types aren't === equal.\n\n    var needsCompareFamilies = false;\n    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n    switch (fiber.tag) {\n      case ClassComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case FunctionComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            // We don't know the inner type yet.\n            // We're going to assume that the lazy inner type is stable,\n            // and so it is sufficient to avoid reconciling it away.\n            // We're not going to unwrap or actually use the new lazy type.\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case ForwardRef:\n        {\n          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ($$typeofNextType === REACT_MEMO_TYPE) {\n            // TODO: if it was but can no longer be simple,\n            // we shouldn't set this.\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      default:\n        return false;\n    } // Check if both types have a family and it's the same one.\n\n\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      var prevFamily = resolveFamily(prevType);\n\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\nfunction markFailedErrorBoundaryForHotReloading(fiber) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n\n    failedBoundaries.add(fiber);\n  }\n}\nvar scheduleRefresh = function (root, update) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    var staleFamilies = update.staleFamilies,\n        updatedFamilies = update.updatedFamilies;\n    flushPassiveEffects();\n    flushSync(function () {\n      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n    });\n  }\n};\nvar scheduleRoot = function (root, element) {\n  {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n\n    flushPassiveEffects();\n    flushSync(function () {\n      updateContainer(element, root, null, null);\n    });\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n  {\n    var alternate = fiber.alternate,\n        child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    var needsRender = false;\n    var needsRemount = false;\n\n    if (candidateType !== null) {\n      var family = resolveFamily(candidateType);\n\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          if (tag === ClassComponent) {\n            needsRemount = true;\n          } else {\n            needsRender = true;\n          }\n        }\n      }\n    }\n\n    if (failedBoundaries !== null) {\n      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n\n    if (needsRemount || needsRender) {\n      var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (_root !== null) {\n        scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n    }\n\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n  }\n}\n\nvar findHostInstancesForRefresh = function (root, families) {\n  {\n    var hostInstances = new Set();\n    var types = new Set(families.map(function (family) {\n      return family.current;\n    }));\n    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n    return hostInstances;\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n  {\n    var child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    var didMatch = false;\n\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n    if (foundHostInstances) {\n      return;\n    } // If we didn't find any host children, fallback to closest host parent.\n\n\n    var node = fiber;\n\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var node = fiber;\n    var foundHostInstances = false;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  return false;\n}\n\nvar hasBadMapPolyfill;\n\n{\n  hasBadMapPolyfill = false;\n\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null; // Fiber\n\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode; // Effects\n\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n  this.alternate = null;\n\n  {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n} // This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\n\n\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct$1(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction isSimpleFunctionComponent(type) {\n  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;\n}\nfunction resolveLazyComponentTag(Component) {\n  if (typeof Component === 'function') {\n    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n  } else if (Component !== undefined && Component !== null) {\n    var $$typeof = Component.$$typeof;\n\n    if ($$typeof === REACT_FORWARD_REF_TYPE) {\n      return ForwardRef;\n    }\n\n    if ($$typeof === REACT_MEMO_TYPE) {\n      return MemoComponent;\n    }\n  }\n\n  return IndeterminateComponent;\n} // This is used to create an alternate fiber to do work on.\n\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n      workInProgress._debugHookTypes = current._debugHookTypes;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // We already have an alternate.\n    // Reset the effect tag.\n\n    workInProgress.flags = NoFlags; // The effects are no longer valid.\n\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n\n    {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  } // Reset all effects except static ones.\n  // Static effects are not specific to a render.\n\n\n  workInProgress.flags = current.flags & StaticMask;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n\n  var currentDependencies = current.dependencies;\n  workInProgress.dependencies = currentDependencies === null ? null : {\n    lanes: currentDependencies.lanes,\n    firstContext: currentDependencies.firstContext\n  }; // These will be overridden during the parent's reconciliation\n\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  {\n    workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n      case FunctionComponent:\n      case SimpleMemoComponent:\n        workInProgress.type = resolveFunctionForHotReloading(current.type);\n        break;\n\n      case ClassComponent:\n        workInProgress.type = resolveClassForHotReloading(current.type);\n        break;\n\n      case ForwardRef:\n        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        break;\n    }\n  }\n\n  return workInProgress;\n} // Used to reuse a Fiber for a second pass.\n\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  // This resets the Fiber to what createFiber or createWorkInProgress would\n  // have set the values to before during the first pass. Ideally this wouldn't\n  // be necessary but unfortunately many code paths reads from the workInProgress\n  // when they should be reading from current and writing to workInProgress.\n  // We assume pendingProps, index, key, ref, return are still untouched to\n  // avoid doing another reconciliation.\n  // Reset the effect flags but keep any Placement tags, since that's something\n  // that child fiber is setting, not the reconciliation.\n  workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n\n  var current = workInProgress.alternate;\n\n  if (current === null) {\n    // Reset to createFiber's initial values.\n    workInProgress.childLanes = NoLanes;\n    workInProgress.lanes = renderLanes;\n    workInProgress.child = null;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.memoizedProps = null;\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n    workInProgress.dependencies = null;\n    workInProgress.stateNode = null;\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = 0;\n      workInProgress.treeBaseDuration = 0;\n    }\n  } else {\n    // Reset to the cloned values that createWorkInProgress would've.\n    workInProgress.childLanes = current.childLanes;\n    workInProgress.lanes = current.lanes;\n    workInProgress.child = current.child;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n    workInProgress.memoizedProps = current.memoizedProps;\n    workInProgress.memoizedState = current.memoizedState;\n    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n    // it cannot be shared with the current fiber.\n\n    var currentDependencies = current.dependencies;\n    workInProgress.dependencies = currentDependencies === null ? null : {\n      lanes: currentDependencies.lanes,\n      firstContext: currentDependencies.firstContext\n    };\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = current.selfBaseDuration;\n      workInProgress.treeBaseDuration = current.treeBaseDuration;\n    }\n  }\n\n  return workInProgress;\n}\nfunction createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n  var mode;\n\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n\n    if (isStrictMode === true) {\n      mode |= StrictLegacyMode;\n\n      {\n        mode |= StrictEffectsMode;\n      }\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if ( isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\u2013\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\nfunction createFiberFromTypeAndProps(type, // React$ElementType\nkey, pendingProps, owner, mode, lanes) {\n  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\n  var resolvedType = type;\n\n  if (typeof type === 'function') {\n    if (shouldConstruct$1(type)) {\n      fiberTag = ClassComponent;\n\n      {\n        resolvedType = resolveClassForHotReloading(resolvedType);\n      }\n    } else {\n      {\n        resolvedType = resolveFunctionForHotReloading(resolvedType);\n      }\n    }\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictLegacyMode;\n\n        if ( (mode & ConcurrentMode) !== NoMode) {\n          // Strict effects should never run on legacy roots\n          mode |= StrictEffectsMode;\n        }\n\n        break;\n\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_TYPE:\n        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_LIST_TYPE:\n        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n\n      case REACT_OFFSCREEN_TYPE:\n        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n\n      case REACT_LEGACY_HIDDEN_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_SCOPE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_CACHE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_TRACING_MARKER_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_DEBUG_TRACING_MODE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break getTag;\n\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break getTag;\n\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n\n                {\n                  resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                }\n\n                break getTag;\n\n              case REACT_MEMO_TYPE:\n                fiberTag = MemoComponent;\n                break getTag;\n\n              case REACT_LAZY_TYPE:\n                fiberTag = LazyComponent;\n                resolvedType = null;\n                break getTag;\n            }\n          }\n\n          var info = '';\n\n          {\n            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n            }\n\n            var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n\n            if (ownerName) {\n              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n            }\n          }\n\n          throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n    }\n  }\n\n  var fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.elementType = type;\n  fiber.type = resolvedType;\n  fiber.lanes = lanes;\n\n  {\n    fiber._debugOwner = owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromElement(element, mode, lanes) {\n  var owner = null;\n\n  {\n    owner = element._owner;\n  }\n\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, lanes, key) {\n  {\n    if (typeof pendingProps.id !== 'string') {\n      error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.elementType = REACT_PROFILER_TYPE;\n  fiber.lanes = lanes;\n\n  {\n    fiber.stateNode = {\n      effectDuration: 0,\n      passiveEffectDuration: 0\n    };\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromSuspense(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_OFFSCREEN_TYPE;\n  fiber.lanes = lanes;\n  var primaryChildInstance = {\n    isHidden: false\n  };\n  fiber.stateNode = primaryChildInstance;\n  return fiber;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoMode);\n  fiber.elementType = 'DELETED';\n  return fiber;\n}\nfunction createFiberFromDehydratedFragment(dehydratedNode) {\n  var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n  fiber.stateNode = dehydratedNode;\n  return fiber;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.lanes = lanes;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n} // Used for stashing WIP properties to replay failed work in DEV.\n\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoMode);\n  } // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.elementType = source.elementType;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.dependencies = source.dependencies;\n  target.mode = source.mode;\n  target.flags = source.flags;\n  target.subtreeFlags = source.subtreeFlags;\n  target.deletions = source.deletions;\n  target.lanes = source.lanes;\n  target.childLanes = source.childLanes;\n  target.alternate = source.alternate;\n\n  {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugNeedsRemount = source._debugNeedsRemount;\n  target._debugHookTypes = source._debugHookTypes;\n  return target;\n}\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  {\n    this.memoizedUpdaters = new Set();\n    var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (var _i = 0; _i < TotalLanes; _i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\nfunction createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n  // stateNode is any.\n\n\n  var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  {\n    var _initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null,\n      // not enabled yet\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    uninitializedFiber.memoizedState = _initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n  return root;\n}\n\nvar ReactVersion = '18.3.1';\n\nfunction createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  {\n    checkKeyStringCoercion(key);\n  }\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar didWarnAboutNestedUpdates;\nvar didWarnAboutFindNodeInStrictMode;\n\n{\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      var keys = Object.keys(component).join(',');\n      throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n    }\n  }\n\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  {\n    var fiber = get(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        var keys = Object.keys(component).join(',');\n        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n      }\n    }\n\n    var hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      var componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        var previousFiber = current;\n\n        try {\n          setCurrentFiber(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentFiber(previousFiber);\n          } else {\n            resetCurrentFiber();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n}\n\nfunction createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = false;\n  var initialChildren = null;\n  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n}\nfunction createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\ncallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = true;\n  var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n\n  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n\n  var current = root.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current);\n  var update = createUpdate(eventTime, lane);\n  update.callback = callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update, lane);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n  return root;\n}\nfunction updateContainer(element, container, parentComponent, callback) {\n  {\n    onScheduleRoot(container, element);\n  }\n\n  var current$1 = container.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current$1);\n\n  {\n    markRenderScheduled(lane);\n  }\n\n  var context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  {\n    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n\n      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  var root = enqueueUpdate(current$1, update, lane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, current$1, lane, eventTime);\n    entangleTransitions(root, current$1, lane);\n  }\n\n  return lane;\n}\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nfunction attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      {\n        var root = fiber.stateNode;\n\n        if (isRootDehydrated(root)) {\n          // Flush the first scheduled \"update\".\n          var lanes = getHighestPriorityPendingLanes(root);\n          flushRoot(root, lanes);\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        flushSync(function () {\n          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n          if (root !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);\n          }\n        }); // If we're still blocked after this, we need to increase\n        // the priority of any promises resolving within this\n        // boundary so that they next attempt also has higher pri.\n\n        var retryLane = SyncLane;\n        markRetryLaneIfNotHydrated(fiber, retryLane);\n        break;\n      }\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  var suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  var alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nfunction attemptDiscreteHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  var lane = SyncLane;\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  var lane = SelectiveHydrationLane;\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nvar shouldErrorImpl = function (fiber) {\n  return null;\n};\n\nfunction shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nvar shouldSuspendImpl = function (fiber) {\n  return false;\n};\n\nfunction shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nvar overrideHookState = null;\nvar overrideHookStateDeletePath = null;\nvar overrideHookStateRenamePath = null;\nvar overrideProps = null;\nvar overridePropsDeletePath = null;\nvar overridePropsRenamePath = null;\nvar scheduleUpdate = null;\nvar setErrorHandler = null;\nvar setSuspenseHandler = null;\n\n{\n  var copyWithDeleteImpl = function (obj, path, index) {\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  var copyWithDelete = function (obj, path) {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {\n    var oldKey = oldPath[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === oldPath.length) {\n      var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  var copyWithRename = function (obj, oldPath, newPath) {\n    if (oldPath.length !== newPath.length) {\n      warn('copyWithRename() expects paths of the same length');\n\n      return;\n    } else {\n      for (var i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          warn('copyWithRename() expects paths to be the same except for the deepest key');\n\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  var copyWithSetImpl = function (obj, path, index, value) {\n    if (index >= path.length) {\n      return value;\n    }\n\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  var copyWithSet = function (obj, path, value) {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  var findHook = function (fiber, id) {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    var currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = function (fiber, id, path, value) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateDeletePath = function (fiber, id, path) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = function (fiber, path, value) {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsDeletePath = function (fiber, path) {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsRenamePath = function (fiber, oldPath, newPath) {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  scheduleUpdate = function (fiber) {\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  setErrorHandler = function (newShouldErrorImpl) {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = function (newShouldSuspendImpl) {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return current;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState: overrideHookState,\n    overrideHookStateDeletePath: overrideHookStateDeletePath,\n    overrideHookStateRenamePath: overrideHookStateRenamePath,\n    overrideProps: overrideProps,\n    overridePropsDeletePath: overridePropsDeletePath,\n    overridePropsRenamePath: overridePropsRenamePath,\n    setErrorHandler: setErrorHandler,\n    setSuspenseHandler: setSuspenseHandler,\n    scheduleUpdate: scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber: findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh:  findHostInstancesForRefresh ,\n    scheduleRefresh:  scheduleRefresh ,\n    scheduleRoot:  scheduleRoot ,\n    setRefreshHandler:  setRefreshHandler ,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber:  getCurrentFiberForDevTools ,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}\n\nexports.attemptContinuousHydration = attemptContinuousHydration;\nexports.attemptDiscreteHydration = attemptDiscreteHydration;\nexports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\nexports.attemptSynchronousHydration = attemptSynchronousHydration;\nexports.batchedUpdates = batchedUpdates;\nexports.createComponentSelector = createComponentSelector;\nexports.createContainer = createContainer;\nexports.createHasPseudoClassSelector = createHasPseudoClassSelector;\nexports.createHydrationContainer = createHydrationContainer;\nexports.createPortal = createPortal;\nexports.createRoleSelector = createRoleSelector;\nexports.createTestNameSelector = createTestNameSelector;\nexports.createTextSelector = createTextSelector;\nexports.deferredUpdates = deferredUpdates;\nexports.discreteUpdates = discreteUpdates;\nexports.findAllNodes = findAllNodes;\nexports.findBoundingRects = findBoundingRects;\nexports.findHostInstance = findHostInstance;\nexports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\nexports.findHostInstanceWithWarning = findHostInstanceWithWarning;\nexports.flushControlled = flushControlled;\nexports.flushPassiveEffects = flushPassiveEffects;\nexports.flushSync = flushSync;\nexports.focusWithin = focusWithin;\nexports.getCurrentUpdatePriority = getCurrentUpdatePriority;\nexports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\nexports.getPublicRootInstance = getPublicRootInstance;\nexports.injectIntoDevTools = injectIntoDevTools;\nexports.isAlreadyRendering = isAlreadyRendering;\nexports.observeVisibleRects = observeVisibleRects;\nexports.registerMutableSourceForHydration = registerMutableSourceForHydration;\nexports.runWithPriority = runWithPriority;\nexports.shouldError = shouldError;\nexports.shouldSuspend = shouldSuspend;\nexports.updateContainer = updateContainer;\n    return exports;\n  };\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-reconciler.production.min.js');\n} else {\n  module.exports = require('./cjs/react-reconciler.development.js');\n}\n", "/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n", "import { RETAINED_BY, RETAIN_METHOD, RELEASE_METHOD } from './types.mjs';\nexport { RELEASE_METHOD, RETAINED_BY, RETAIN_METHOD } from './types.mjs';\n\nclass StackFrame {\n  constructor() {\n    this.memoryManaged = new Set();\n  }\n\n  add(memoryManageable) {\n    this.memoryManaged.add(memoryManageable);\n    memoryManageable[RETAINED_BY].add(this);\n    memoryManageable[RETAIN_METHOD]();\n  }\n\n  release() {\n    for (const memoryManaged of this.memoryManaged) {\n      memoryManaged[RETAINED_BY].delete(this);\n      memoryManaged[RELEASE_METHOD]();\n    }\n\n    this.memoryManaged.clear();\n  }\n\n}\nfunction isMemoryManageable(value) {\n  return Boolean(value && value[RETAIN_METHOD] && value[RELEASE_METHOD]);\n}\nfunction retain(value, {\n  deep = true\n} = {}) {\n  return retainInternal(value, deep, new Map());\n}\n\nfunction retainInternal(value, deep, seen) {\n  const seenValue = seen.get(value);\n  if (seenValue != null) return seenValue;\n  const canRetain = isMemoryManageable(value);\n\n  if (canRetain) {\n    value[RETAIN_METHOD]();\n  }\n\n  seen.set(value, canRetain);\n\n  if (deep) {\n    if (Array.isArray(value)) {\n      const nestedCanRetain = value.reduce((canRetain, item) => retainInternal(item, deep, seen) || canRetain, canRetain);\n      seen.set(value, nestedCanRetain);\n      return nestedCanRetain;\n    }\n\n    if (isBasicObject(value)) {\n      const nestedCanRetain = Object.keys(value).reduce((canRetain, key) => retainInternal(value[key], deep, seen) || canRetain, canRetain);\n      seen.set(value, nestedCanRetain);\n      return nestedCanRetain;\n    }\n  }\n\n  seen.set(value, canRetain);\n  return canRetain;\n}\n\nfunction release(value, {\n  deep = true\n} = {}) {\n  return releaseInternal(value, deep, new Map());\n}\nfunction releaseInternal(value, deep, seen) {\n  const seenValue = seen.get(value);\n  if (seenValue != null) return seenValue;\n  const canRelease = isMemoryManageable(value);\n\n  if (canRelease) {\n    value[RELEASE_METHOD]();\n  }\n\n  seen.set(value, canRelease);\n\n  if (deep) {\n    if (Array.isArray(value)) {\n      const nestedCanRelease = value.reduce((canRelease, item) => releaseInternal(item, deep, seen) || canRelease, canRelease);\n      seen.set(value, nestedCanRelease);\n      return nestedCanRelease;\n    }\n\n    if (isBasicObject(value)) {\n      const nestedCanRelease = Object.keys(value).reduce((canRelease, key) => releaseInternal(value[key], deep, seen) || canRelease, canRelease);\n      seen.set(value, nestedCanRelease);\n      return nestedCanRelease;\n    }\n  }\n\n  return canRelease;\n}\nfunction isBasicObject(value) {\n  if (value == null || typeof value !== 'object') return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype == null || prototype === Object.prototype;\n}\n\nexport { StackFrame, isBasicObject, isMemoryManageable, release, releaseInternal, retain };\n", "import { KIND_COMPONENT, KIND_TEXT, KIND_FRAGMENT } from './types.mjs';\n\nfunction isRemoteComponent(child) {\n  return child != null && child.kind === KIND_COMPONENT;\n}\nfunction isRemoteText(child) {\n  return child != null && child.kind === KIND_TEXT;\n}\nfunction isRemoteFragment(object) {\n  return object != null && object.kind === KIND_FRAGMENT;\n}\n\nexport { isRemoteComponent, isRemoteFragment, isRemoteText };\n", "import { isBasicObject } from '@remote-ui/rpc';\nimport { KIND_ROOT, ACTION_MOUNT, ACTION_INSERT_CHILD, KIND_TEXT, ACTION_REMOVE_CHILD, KIND_COMPONENT, KIND_FRAGMENT, ACTION_UPDATE_PROPS, ACTION_UPDATE_TEXT } from './types.mjs';\nimport { isRemoteFragment } from './utilities.mjs';\n\nconst FUNCTION_CURRENT_IMPLEMENTATION_KEY = '__current';\nconst EMPTY_OBJECT = {};\nconst EMPTY_ARRAY = [];\nfunction createRemoteRoot(channel, {\n  strict = true,\n  components\n} = {}) {\n  let currentId = 0;\n  const rootInternals = {\n    strict,\n    mounted: false,\n    channel,\n    children: EMPTY_ARRAY,\n    nodes: new WeakSet(),\n    parents: new WeakMap(),\n    tops: new WeakMap(),\n    components: new WeakMap(),\n    fragments: new WeakMap()\n  };\n  if (strict) Object.freeze(components);\n  const remoteRoot = {\n    kind: KIND_ROOT,\n    options: strict ? Object.freeze({\n      strict,\n      components\n    }) : {\n      strict,\n      components\n    },\n\n    get children() {\n      return rootInternals.children;\n    },\n\n    createComponent(type, ...rest) {\n      if (components && components.indexOf(type) < 0) {\n        throw new Error(`Unsupported component: ${type}`);\n      }\n\n      const [initialProps, initialChildren, ...moreChildren] = rest;\n      const normalizedInitialProps = initialProps !== null && initialProps !== void 0 ? initialProps : {};\n      const normalizedInitialChildren = [];\n      const normalizedInternalProps = {};\n\n      if (initialProps) {\n        for (const key of Object.keys(initialProps)) {\n          // \"children\" as a prop can be extremely confusing with the \"children\" of\n          // a component. In React, a \"child\" can be anything, but once it reaches\n          // a host environment (like this remote `Root`), we want \"children\" to have\n          // only one meaning: the actual, resolved children components and text.\n          //\n          // To enforce this, we delete any prop named \"children\". We don\u2019t take a copy\n          // of the props for performance, so a user calling this function must do so\n          // with an object that can handle being mutated.\n          if (key === 'children') continue;\n          normalizedInternalProps[key] = makeValueHotSwappable(serializeProp(initialProps[key]));\n        }\n      }\n\n      if (initialChildren) {\n        if (Array.isArray(initialChildren)) {\n          for (const child of initialChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        } else {\n          normalizedInitialChildren.push(normalizeChild(initialChildren, remoteRoot)); // The complex tuple type of `rest` makes it so `moreChildren` is\n          // incorrectly inferred as potentially being the props of the component,\n          // lazy casting since we know it will be an array of child elements\n          // (or empty).\n\n          for (const child of moreChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        }\n      }\n\n      const id = `${currentId++}`;\n      const internals = {\n        externalProps: strict ? Object.freeze(normalizedInitialProps) : normalizedInitialProps,\n        internalProps: normalizedInternalProps,\n        children: strict ? Object.freeze(normalizedInitialChildren) : normalizedInitialChildren\n      };\n      const component = {\n        kind: KIND_COMPONENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        get props() {\n          return internals.externalProps;\n        },\n\n        get remoteProps() {\n          return internals.internalProps;\n        },\n\n        remove: () => remove(component),\n        updateProps: newProps => updateProps(component, newProps, internals, rootInternals),\n        append: (...children) => append(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(component, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(component, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually, which we do below. If we just `as any`\n        // the whole object, we lose the implicit argument types for the\n        // methods above.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.components.set(component, internals);\n      Object.defineProperty(component, 'type', {\n        value: type,\n        configurable: false,\n        writable: false,\n        enumerable: true\n      });\n      makePartOfTree(component, rootInternals);\n      makeRemote(component, id, remoteRoot);\n\n      for (const child of internals.children) {\n        moveNodeToContainer(component, child, rootInternals);\n      }\n\n      return component;\n    },\n\n    createText(content = '') {\n      const id = `${currentId++}`;\n      const internals = {\n        text: content\n      };\n\n      const update = newText => updateText(text, newText, internals, rootInternals);\n\n      const text = {\n        kind: KIND_TEXT,\n\n        get text() {\n          return internals.text;\n        },\n\n        update,\n        updateText: update,\n        remove: () => remove(text),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      makePartOfTree(text, rootInternals);\n      makeRemote(text, id, remoteRoot);\n      return text;\n    },\n\n    createFragment() {\n      const id = `${currentId++}`;\n      const internals = {\n        children: strict ? Object.freeze([]) : []\n      };\n      const fragment = {\n        kind: KIND_FRAGMENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        append: (...children) => append(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(fragment, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(fragment, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.fragments.set(fragment, internals);\n      makePartOfTree(fragment, rootInternals);\n      makeRemote(fragment, id, remoteRoot);\n      return fragment;\n    },\n\n    append: (...children) => append(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    appendChild: child => appendChild(remoteRoot, normalizeChild(child, remoteRoot), rootInternals, rootInternals),\n    replaceChildren: (...children) => replaceChildren(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    removeChild: child => removeChild(remoteRoot, child, rootInternals, rootInternals),\n    insertBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n    insertChildBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n\n    mount() {\n      if (rootInternals.mounted) return Promise.resolve();\n      rootInternals.mounted = true;\n      return Promise.resolve(channel(ACTION_MOUNT, rootInternals.children.map(serializeChild)));\n    }\n\n  };\n  return remoteRoot;\n}\n\nfunction connected(element, {\n  tops\n}) {\n  var _tops$get;\n\n  return ((_tops$get = tops.get(element)) === null || _tops$get === void 0 ? void 0 : _tops$get.kind) === KIND_ROOT;\n}\n\nfunction allDescendants(element, withEach) {\n  const recurse = element => {\n    if ('children' in element) {\n      for (const child of element.children) {\n        withEach(child);\n        recurse(child);\n      }\n    }\n  };\n\n  recurse(element);\n}\n\nfunction perform(element, rootInternals, {\n  remote,\n  local\n}) {\n  const {\n    mounted,\n    channel\n  } = rootInternals;\n\n  if (mounted && (element.kind === KIND_ROOT || connected(element, rootInternals))) {\n    // should only create context once async queue is cleared\n    remote(channel); // technically, we should be waiting for the remote update to apply,\n    // then apply it locally. The implementation below is too naive because\n    // it allows local updates to get out of sync with remote ones.\n    // if (remoteResult == null || !('then' in remoteResult)) {\n    //   local();\n    //   return;\n    // } else {\n    //   return remoteResult.then(() => {\n    //     local();\n    //   });\n    // }\n  }\n\n  local();\n}\n\nfunction updateText(text, newText, internals, rootInternals) {\n  return perform(text, rootInternals, {\n    remote: channel => channel(ACTION_UPDATE_TEXT, text.id, newText),\n    local: () => {\n      internals.text = newText;\n    }\n  });\n}\n\nconst IGNORE = Symbol('ignore');\n\nfunction updateProps(component, newProps, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const {\n    internalProps: currentProps,\n    externalProps: currentExternalProps\n  } = internals;\n  const normalizedNewProps = {};\n  const hotSwapFunctions = [];\n  let hasRemoteChange = false;\n\n  for (const key of Object.keys(newProps)) {\n    // See notes above for why we treat `children` as a reserved prop.\n    if (key === 'children') continue;\n    const currentExternalValue = currentExternalProps[key];\n    const newExternalValue = newProps[key];\n    const currentValue = currentProps[key];\n    const newValue = serializeProp(newExternalValue); // Bail out if we have equal, primitive types\n\n    if (currentValue === newValue && (newValue == null || typeof newValue !== 'object')) {\n      continue;\n    }\n\n    const [value, hotSwaps] = tryHotSwappingValues(currentValue, newValue);\n\n    if (hotSwaps) {\n      hotSwapFunctions.push(...hotSwaps);\n    }\n\n    if (value === IGNORE) continue;\n    hasRemoteChange = true;\n    normalizedNewProps[key] = value;\n\n    if (isRemoteFragment(currentExternalValue)) {\n      removeNodeFromContainer(currentExternalValue, rootInternals);\n    }\n\n    if (isRemoteFragment(newExternalValue)) {\n      moveNodeToContainer(component, newExternalValue, rootInternals);\n    }\n  }\n\n  return perform(component, rootInternals, {\n    remote: channel => {\n      if (hasRemoteChange) {\n        channel(ACTION_UPDATE_PROPS, component.id, normalizedNewProps);\n      }\n    },\n    local: () => {\n      const mergedExternalProps = { ...currentExternalProps,\n        ...newProps\n      };\n      internals.externalProps = strict ? Object.freeze(mergedExternalProps) : mergedExternalProps;\n      internals.internalProps = { ...internals.internalProps,\n        ...normalizedNewProps\n      };\n\n      for (const [hotSwappable, newValue] of hotSwapFunctions) {\n        hotSwappable[FUNCTION_CURRENT_IMPLEMENTATION_KEY] = newValue;\n      }\n    }\n  });\n} // Imagine the following remote-ui components we might render in a remote context:\n//\n// const root = createRemoteRoot();\n// const {value, onChange, onPress} = getPropsForValue();\n//\n// const textField = root.createComponent('TextField', {value, onChange});\n// const button = root.createComponent('Button', {onPress});\n//\n// root.append(textField);\n// root.append(button);\n//\n// function getPropsForValue(value = '') {\n//   return {\n//     value,\n//     onChange: () => {\n//       const {value, onChange, onPress} = getPropsForValue();\n//       textField.updateProps({value, onChange});\n//       button.updateProps({onPress});\n//     },\n//     onPress: () => console.log(value),\n//   };\n// }\n//\n//\n// In this example, assume that the `TextField` `onChange` prop is run on blur.\n// If this were running on the host, the following steps would happen if you pressed\n// on the button:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value, which\n//    then calls `setValue()` with the updated value.\n// 2. We synchronously update the `value`, `onChange`, and `onPress` props to point at\n//    the most current `value`.\n// 3. Handling blur is finished, so the browser now handles the click by calling the\n//    (newly-updated) `Button` `onPress()`, which logs out the new value.\n//\n// Because remote-ui reproduces a UI tree asynchronously from the remote context, the\n// steps above run in a different order:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value.\n// 2. Handling blur is finished **from the perspective of the main thread**, so the\n//    browser now handles the click by calling the (original) `Button` `onPress()`, which\n//    logs out the **initial** value.\n// 3. In the remote context, we receive the `onChange()` call, which calls updates the props\n//    on the `Button` and `TextField` to be based on the new `value`, but by now it\u2019s\n//    already too late for `onPress` \u2014 the old version has already been called!\n//\n// As you can see, the timing issue introduced by the asynchronous nature of remote-ui\n// can cause \u201Cold props\u201D to be called from the main thread. This example may seem like\n// an unusual pattern, and it is if you are using `@remote-ui/core` directly; you\u2019d generally\n// keep a mutable reference to the state, instead of closing over the state with new props.\n// However, abstractions on top of `@remote-ui/core`, like the React reconciler in\n// `@remote-ui/react`, work almost entirely by closing over state, so this issue is\n// much more common with those declarative libraries.\n//\n// To protect against this, we handle function props a bit differently. When we have a\n// function prop, we replace it with a new function that calls the original. However,\n// we make the original mutable, by making it a property on the function itself. When\n// this function subsequently updates, we don\u2019t send the update to the main thread (as\n// we just saw, this can often be \"too late\" to be of any use). Instead, we swap out\n// the mutable reference to the current implementation of the function prop, which can\n// be done synchronously. In the example above, this would all happen synchronously in\n// the remote context; in our handling of `TextField onChange()`, we update `Button onPress()`,\n// and swap out the implementations. Now, when the main thread attempts to call `Button onPress()`,\n// it instead calls our wrapper around the function, which can refer to, and call, the\n// most recently-applied implementation, instead of directly calling the old implementation.\n\n\nfunction tryHotSwappingValues(currentValue, newValue, seen = new Set()) {\n  if (seen.has(currentValue)) {\n    return [IGNORE];\n  }\n\n  if (typeof currentValue === 'function' && FUNCTION_CURRENT_IMPLEMENTATION_KEY in currentValue) {\n    seen.add(currentValue);\n    const result = [typeof newValue === 'function' ? IGNORE : makeValueHotSwappable(newValue), [[currentValue, newValue]]];\n    return result;\n  }\n\n  if (Array.isArray(currentValue)) {\n    seen.add(currentValue);\n    const result = tryHotSwappingArrayValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  if (isBasicObject(currentValue) && !isRemoteFragment(currentValue)) {\n    seen.add(currentValue);\n    const result = tryHotSwappingObjectValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  const result = [currentValue === newValue ? IGNORE : newValue];\n  return result;\n}\n\nfunction makeValueHotSwappable(value, seen = new Map()) {\n  const seenValue = seen.get(value);\n  if (seenValue) return seenValue;\n\n  if (isRemoteFragment(value)) {\n    seen.set(value, value);\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    const result = [];\n    seen.set(value, result);\n\n    for (const nested of value) {\n      result.push(makeValueHotSwappable(nested, seen));\n    }\n\n    return result;\n  }\n\n  if (isBasicObject(value)) {\n    const result = {};\n    seen.set(value, result);\n\n    for (const key of Object.keys(value)) {\n      result[key] = makeValueHotSwappable(value[key], seen);\n    }\n\n    return result;\n  }\n\n  if (typeof value === 'function') {\n    const wrappedFunction = (...args) => {\n      return wrappedFunction[FUNCTION_CURRENT_IMPLEMENTATION_KEY](...args);\n    };\n\n    Object.defineProperty(wrappedFunction, FUNCTION_CURRENT_IMPLEMENTATION_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value\n    });\n    seen.set(value, wrappedFunction);\n    return wrappedFunction;\n  }\n\n  return value;\n}\n\nfunction collectNestedHotSwappableValues(value, seen = new Set()) {\n  if (seen.has(value)) return undefined;\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.reduce((all, element) => {\n      const nested = collectNestedHotSwappableValues(element, seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (isBasicObject(value)) {\n    return Object.keys(value).reduce((all, key) => {\n      const nested = collectNestedHotSwappableValues(value[key], seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (typeof value === 'function') {\n    return FUNCTION_CURRENT_IMPLEMENTATION_KEY in value ? [value] : undefined;\n  }\n\n  return undefined;\n}\n\nfunction remove(child) {\n  var _child$parent;\n\n  (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child);\n}\n\nfunction append(container, children, internals, rootInternals) {\n  for (const child of children) {\n    appendChild(container, child, internals, rootInternals);\n  }\n}\n\nfunction appendChild(container, child, internals, rootInternals) {\n  var _currentParent$childr;\n\n  const {\n    nodes,\n    strict\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot append a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr !== void 0 ? _currentParent$childr : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      channel(ACTION_INSERT_CHILD, container.id, existingIndex < 0 ? container.children.length : container.children.length - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      newChildren.push(child);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction replaceChildren(container, children, internals, rootInternals) {\n  for (const child of container.children) {\n    removeChild(container, child, internals, rootInternals);\n  }\n\n  append(container, children, internals, rootInternals);\n} // there is a problem with this, because when multiple children\n// are removed, there is no guarantee the messages will arrive in the\n// order we need them to on the host side (it depends how React\n// calls our reconciler). If it calls with, for example, the removal of\n// the second last item, then the removal of the last item, it will fail\n// because the indexes moved around.\n//\n// Might need to send the removed child ID, or find out if we\n// can collect removals into a single update.\n\n\nfunction removeChild(container, child, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const childIndex = container.children.indexOf(child);\n\n  if (childIndex === -1) {\n    return undefined;\n  }\n\n  return perform(container, rootInternals, {\n    remote: channel => channel(ACTION_REMOVE_CHILD, container.id, childIndex),\n    local: () => {\n      removeNodeFromContainer(child, rootInternals);\n      const newChildren = [...internals.children];\n      newChildren.splice(newChildren.indexOf(child), 1);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction insertBefore(container, child, before, internals, rootInternals) {\n  var _currentParent$childr2;\n\n  const {\n    strict,\n    nodes\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot insert a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr2 = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr2 !== void 0 ? _currentParent$childr2 : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      const beforeIndex = before == null ? container.children.length - 1 : container.children.indexOf(before);\n      channel(ACTION_INSERT_CHILD, container.id, beforeIndex < existingIndex || existingIndex < 0 ? beforeIndex : beforeIndex - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      if (before == null) {\n        newChildren.push(child);\n      } else {\n        newChildren.splice(newChildren.indexOf(before), 0, child);\n      }\n\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction normalizeChild(child, root) {\n  return typeof child === 'string' ? root.createText(child) : child;\n}\n\nfunction moveNodeToContainer(container, node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  const newTop = container.kind === KIND_ROOT ? container : tops.get(container);\n  tops.set(node, newTop);\n  parents.set(node, container);\n  moveFragmentToContainer(node, rootInternals);\n  allDescendants(node, descendant => {\n    tops.set(descendant, newTop);\n    moveFragmentToContainer(descendant, rootInternals);\n  });\n}\n\nfunction moveFragmentToContainer(node, rootInternals) {\n  if (node.kind !== KIND_COMPONENT) return;\n  const props = node.props;\n  if (!props) return;\n  Object.values(props).forEach(prop => {\n    if (!isRemoteFragment(prop)) return;\n    moveNodeToContainer(node, prop, rootInternals);\n  });\n}\n\nfunction removeNodeFromContainer(node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  tops.delete(node);\n  parents.delete(node);\n  allDescendants(node, descendant => {\n    tops.delete(descendant);\n    removeFragmentFromContainer(descendant, rootInternals);\n  });\n  removeFragmentFromContainer(node, rootInternals);\n}\n\nfunction removeFragmentFromContainer(node, rootInternals) {\n  if (node.kind !== KIND_COMPONENT) return;\n  const props = node.remoteProps;\n\n  for (const key of Object.keys(props !== null && props !== void 0 ? props : {})) {\n    const prop = props[key];\n    if (!isRemoteFragment(prop)) continue;\n    removeNodeFromContainer(prop, rootInternals);\n  }\n}\n\nfunction makePartOfTree(node, {\n  parents,\n  tops,\n  nodes\n}) {\n  nodes.add(node);\n  Object.defineProperty(node, 'parent', {\n    get() {\n      return parents.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n  Object.defineProperty(node, 'top', {\n    get() {\n      return tops.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction serializeChild(value) {\n  return value.kind === KIND_TEXT ? {\n    id: value.id,\n    kind: value.kind,\n    text: value.text\n  } : {\n    id: value.id,\n    kind: value.kind,\n    type: value.type,\n    props: value.remoteProps,\n    children: value.children.map(child => serializeChild(child))\n  };\n}\n\nfunction serializeProp(prop) {\n  if (isRemoteFragment(prop)) {\n    return serializeFragment(prop);\n  }\n\n  return prop;\n}\n\nfunction serializeFragment(value) {\n  return {\n    id: value.id,\n    kind: value.kind,\n\n    get children() {\n      return value.children.map(child => serializeChild(child));\n    }\n\n  };\n}\n\nfunction getCurrentInternals(currentParent, rootInternals) {\n  if (currentParent.kind === KIND_ROOT) {\n    return rootInternals;\n  }\n\n  if (currentParent.kind === KIND_FRAGMENT) {\n    return rootInternals.fragments.get(currentParent);\n  }\n\n  return rootInternals.components.get(currentParent);\n}\n\nfunction makeRemote(value, id, root) {\n  Object.defineProperty(value, 'id', {\n    value: id,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(value, 'root', {\n    value: root,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\n\nfunction tryHotSwappingObjectValues(currentValue, newValue, seen) {\n  if (!isBasicObject(newValue)) {\n    var _collectNestedHotSwap;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap === void 0 ? void 0 : _collectNestedHotSwap.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const normalizedNewValue = {}; // eslint-disable-next-line guard-for-in\n\n  for (const key in currentValue) {\n    const currentObjectValue = currentValue[key];\n\n    if (!(key in newValue)) {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentObjectValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n\n    const newObjectValue = newValue[key];\n    const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentObjectValue, newObjectValue, seen);\n\n    if (elementHotSwaps) {\n      hotSwaps.push(...elementHotSwaps);\n    }\n\n    if (updatedValue !== IGNORE) {\n      hasChanged = true;\n      normalizedNewValue[key] = updatedValue;\n    }\n  }\n\n  for (const key in newValue) {\n    if (key in normalizedNewValue) continue;\n    hasChanged = true;\n    normalizedNewValue[key] = makeValueHotSwappable(newValue[key]);\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nfunction tryHotSwappingArrayValues(currentValue, newValue, seen) {\n  if (!Array.isArray(newValue)) {\n    var _collectNestedHotSwap2;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap2 = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap2 === void 0 ? void 0 : _collectNestedHotSwap2.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const newLength = newValue.length;\n  const currentLength = currentValue.length;\n  const maxLength = Math.max(currentLength, newLength);\n  const normalizedNewValue = [];\n\n  for (let i = 0; i < maxLength; i++) {\n    const currentArrayValue = currentValue[i];\n    const newArrayValue = newValue[i];\n\n    if (i < newLength) {\n      if (i >= currentLength) {\n        hasChanged = true;\n        normalizedNewValue[i] = makeValueHotSwappable(newArrayValue);\n        continue;\n      }\n\n      const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentArrayValue, newArrayValue, seen);\n      if (elementHotSwaps) hotSwaps.push(...elementHotSwaps);\n\n      if (updatedValue === IGNORE) {\n        normalizedNewValue[i] = currentArrayValue;\n        continue;\n      }\n\n      hasChanged = true;\n      normalizedNewValue[i] = updatedValue;\n    } else {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentArrayValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nexport { createRemoteRoot };\n", "import { createRemoteRoot } from '@remote-ui/core';\n\n/**\n * This function takes an extension function that is expecting a `RemoteRoot` as its\n * first argument, and returns a new function that accepts a `RemoteChannel` instead.\n * This is a convenience that allows the raw UI extension API to only expose the simpler\n * `RemoteChannel` type, while allowing the extension to use the more powerful `RemoteRoot`,\n * provided by a version of `@remote-ui/core` that the extension controls.\n */\nfunction createExtensionRegistrationFunction() {\n  const extensionWrapper = (target, implementation) => {\n    var _shopify;\n    async function extension(...args) {\n      // Rendering extensions have two arguments. Non-rendering extensions don\u2019t have\n      // a `RemoteChannel` that needs to be normalized, so we can just pass the arguments\n      // through.\n      if (args.length === 1) {\n        return implementation(...args);\n      }\n      const [{\n        channel,\n        components\n      }, api] = args;\n      const root = createRemoteRoot(channel, {\n        components,\n        strict: true\n      });\n      let renderResult = implementation(root, api);\n      if (typeof renderResult === 'object' && renderResult != null && 'then' in renderResult) {\n        renderResult = await renderResult;\n      }\n      root.mount();\n      return renderResult;\n    }\n    (_shopify = globalThis.shopify) === null || _shopify === void 0 ? void 0 : _shopify.extend(target, extension);\n    return extension;\n  };\n  return extensionWrapper;\n}\n\nexport { createExtensionRegistrationFunction };\n", "import { createExtensionRegistrationFunction } from '../../utilities/registration.mjs';\n\nconst extension = createExtensionRegistrationFunction();\n\n/**\n * Registers your UI Extension to run for the selected extension target.\n *\n * @param target The extension target you are registering for.\n *\n * @param implementation The function that will be called when Checkout begins rendering\n * your extension. This function is called with the API checkout provided to your\n * extension.\n *\n * @deprecated This is deprecated, use `extension` instead.\n */\nconst extend = extension;\n\nexport { extend, extension };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * Use banners to communicate important messages to customers in a prominent way.\n */\nconst Banner = createRemoteComponent('Banner');\n\nexport { Banner };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * BlockStack is used to vertically stack elements.\n */\nconst BlockStack = createRemoteComponent('BlockStack');\n\nexport { BlockStack };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * Buttons are used for actions, such as \u201CAdd\u201D, \u201CContinue\u201D, \u201CPay now\u201D, or \u201CSave\u201D.\n */\nconst Button = createRemoteComponent('Button');\n\nexport { Button };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * A divider separates content and represents a thematic break between elements.\n */\nconst Divider = createRemoteComponent('Divider');\n\nexport { Divider };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * Headings control the visual style of headings. Use headings to introduce major\n * sections, like Contact information, Shipping address, or Shipping method.\n *\n * Unlike HTML headings, you don\u2019t explicitly specify the position of the heading in the\n * document outline. Nest headings within the heading group component to control\n * the document outline structure used by assistive technologies.\n */\nconst Heading = createRemoteComponent('Heading');\n\nexport { Heading };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * Image is used for large format, responsive images.\n */\nconst Image = createRemoteComponent('Image');\n\nexport { Image };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * InlineStack is used to lay out a horizontal row of elements. Elements always wrap.\n */\nconst InlineStack = createRemoteComponent('InlineStack');\n\nexport { InlineStack };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * Text is used to visually style and provide semantic value for a small piece of text\n * content.\n */\nconst Text = createRemoteComponent('Text');\n\nexport { Text };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n *  View is a generic container component. Its contents will always be their\n * \u201Cnatural\u201D size, so this component can be useful in layout components (like `Grid`,\n * `BlockStack`, `InlineStack`) that would otherwise stretch their children to fit.\n */\nconst View = createRemoteComponent('View');\n\nexport { View };\n", "import { Component } from 'react';\nimport { render as render$1 } from '@remote-ui/react';\nimport { extension } from '@shopify/ui-extensions/checkout';\nimport { ExtensionApiContext } from './context.mjs';\nimport { jsx } from 'react/jsx-runtime';\n\nfunction reactExtension(target, render) {\n  // TypeScript can\u2019t infer the type of the callback because it\u2019s a big union\n  // type. To get around it, we\u2019ll just fake like we are rendering the\n  // purchase.checkout.block.render extension, since all render extensions have the same general\n  // shape (`RenderExtension`).\n  return extension(target, async (root, api) => {\n    const element = await render(api);\n    await new Promise((resolve, reject) => {\n      try {\n        render$1( /*#__PURE__*/jsx(ExtensionApiContext.Provider, {\n          value: api,\n          children: /*#__PURE__*/jsx(ErrorBoundary, {\n            children: element\n          })\n        }), root, () => {\n          resolve();\n        });\n      } catch (error) {\n        // Workaround for https://github.com/Shopify/ui-extensions/issues/325\n        // eslint-disable-next-line no-console\n        console.error(error);\n        reject(error);\n      }\n    });\n  });\n}\n\n/**\n * Registers your React-based UI Extension to run for the selected extension target.\n * Additionally, this function will automatically provide the extension API as React\n * context, which you can access anywhere in your extension by using the `useApi()`\n * hook.\n *\n * @param target The extension target you are registering for. You can see a full list\n * of the available targets in our [developer documentation](https://shopify.dev/docs/api/checkout-ui-extensions/extension-targets-overview#supported-locations).\n *\n * @param render The function that will be called when Checkout begins rendering\n * your extension. This function is called with the API checkout provided to your\n * extension, and must return a React element that will be rendered into the extension\n * target you specified. Alternatively, it can return a promise for a React element,\n * which allows you to perform initial asynchronous work like fetching data from your\n * own backend.\n *\n * @deprecated This is deprecated. Use `reactExtension` instead.\n */\nfunction render(target, render) {\n  return reactExtension(target, render);\n}\n// Using ErrorBoundary allows us to relay the errors coming from React reconcilation\n// to the global object using reportError.\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass ErrorBoundary extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      hasError: false\n    };\n  }\n  static getDerivedStateFromError() {\n    // Update state so the next render will show the fallback UI.\n    return {\n      hasError: true\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    // in development, these errors are logged by React itself so we don\u2019t need to re-log them\n    // eslint-disable-next-line no-process-env\n    if (process.env.NODE_ENV !== 'development') {\n      // eslint-disable-next-line no-console\n      console.error(`The above error occurred in the <${extractComponentName(errorInfo.componentStack)}> component:\\n${errorInfo.componentStack}`);\n    }\n    reportError(error);\n  }\n  render() {\n    if (this.state.hasError) {\n      return null;\n    }\n    return this.props.children;\n  }\n}\n\n// This is an example of component stack:\n//\n// at Hello (webpack:///./src/index.tsx_+_220_modules?:1082:9)\n// at Banner\n// at Extension (webpack:///./src/index.tsx_+_220_modules?:1075:7)\n// at render_esnext_ErrorBoundary (webpack:///./src/index.tsx_+_220_modules?:1052:124)\nfunction extractComponentName(componentStack) {\n  var _ref;\n  const match = componentStack.match(/^\\s+at\\s(\\w+)\\s/);\n  return (_ref = match && match[1]) !== null && _ref !== void 0 ? _ref : 'Unknown';\n}\n\nexport { extractComponentName, reactExtension, render };\n", "import { version } from 'react';\nimport { createReconciler } from './reconciler.mjs';\nimport { RenderContext } from './context.mjs';\nimport { jsx } from 'react/jsx-runtime';\n\nconst cache = new WeakMap(); // @see https://github.com/facebook/react/blob/fea6f8da6ab669469f2fa3f18bd3a831f00ab284/packages/react-reconciler/src/ReactRootTags.js#L12\n// We don't support concurrent rendering for now.\n\nconst LEGACY_ROOT = 0;\nconst defaultReconciler = createReconciler();\nfunction createRoot(root) {\n  return {\n    render(children) {\n      render(children, root);\n    },\n\n    unmount() {\n      if (!cache.has(root)) return;\n      render(null, root);\n      cache.delete(root);\n    }\n\n  };\n}\n/**\n * @deprecated Use `createRoot` for a React 18-style rendering API.\n */\n\nfunction render(element, root, callback, reconciler = defaultReconciler) {\n  // First, check if we've already cached a container and render context for this root\n  let cached = cache.get(root);\n\n  if (!cached) {\n    var _version$split;\n\n    const major = Number(((_version$split = version.split('.')) === null || _version$split === void 0 ? void 0 : _version$split[0]) || 18); // Since we haven't created a container for this root yet, create a new one\n\n    const value = {\n      container: major >= 18 ? reconciler.createContainer(root, LEGACY_ROOT, null, false, null, // Might not be necessary\n      'r-ui', () => null, null) : // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - this is to support React 17\n      reconciler.createContainer(root, LEGACY_ROOT, false, null),\n      // We also cache the render context to avoid re-creating it on subsequent render calls\n      renderContext: {\n        root,\n        reconciler\n      }\n    }; // Store the container and render context for retrieval on subsequent render calls\n\n    cache.set(root, value);\n    cached = value;\n  }\n\n  const {\n    container,\n    renderContext\n  } = cached; // callback is cast here because the typings do not mark that argument\n  // as optional, even though it is.\n\n  reconciler.updateContainer(element && /*#__PURE__*/jsx(RenderContext.Provider, {\n    value: renderContext,\n    children: element\n  }), container, null, callback); // Did not work for me because (I think?) it is done by the worker\n  // and therefore has an entirely different React.\n  //\n  // Original code was from:\n  // @see https://github.com/facebook/react/issues/16666\n  // @see https://github.com/michalochman/react-pixi-fiber/pull/148\n  //\n  // reconciler.injectIntoDevTools({\n  //   bundleType: 1,\n  //   findFiberByHostInstance: reconciler.findFiberByHostInstance,\n  //   rendererPackageName: '@remote-ui/react',\n  //   version: '16.9.0',\n  // });\n}\n\nexport { createRoot, render };\n", "import reactReconciler from 'react-reconciler';\n\nconst createReconciler = options => {\n  var _options$primary;\n\n  return reactReconciler({\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - Compat for React <= 17.x\n    now: Date.now,\n    // Timeout\n    scheduleTimeout: setTimeout,\n    cancelTimeout: clearTimeout,\n    noTimeout: false,\n    // Microtask scheduling\n    // @see https://github.com/facebook/react/blob/2c8a1452b82b9ec5ebfa3f370b31fda19610ae92/packages/react-dom/src/client/ReactDOMHostConfig.js#L391-L401\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - types in `@types/react-reconciler` are outdated\n    supportsMicrotasks: true,\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - types in `@types/react-reconciler` are outdated\n    scheduleMicrotask,\n    // Compat for React <= 17.x\n    queueMicrotask: scheduleMicrotask,\n    isPrimaryRenderer: (_options$primary = options === null || options === void 0 ? void 0 : options.primary) !== null && _options$primary !== void 0 ? _options$primary : true,\n    supportsMutation: true,\n    supportsHydration: false,\n    supportsPersistence: false,\n\n    // Context\n    getRootHostContext() {\n      return {};\n    },\n\n    getChildHostContext(context) {\n      return context;\n    },\n\n    // Instances\n    createTextInstance(text, root) {\n      return root.createText(text);\n    },\n\n    createInstance(type, allProps, root) {\n      const {\n        children: _children,\n        ...props\n      } = allProps;\n      return root.createComponent(type, props);\n    },\n\n    // Updates\n    commitTextUpdate(text, _oldText, newText) {\n      text.update(newText);\n    },\n\n    prepareUpdate(_instance, _type, oldProps, newProps) {\n      const updateProps = {};\n      let needsUpdate = false;\n\n      for (const key in oldProps) {\n        if (!has(oldProps, key) || key === 'children') {\n          continue;\n        }\n\n        if (!(key in newProps)) {\n          needsUpdate = true;\n          updateProps[key] = undefined; // } else if (typeof oldProps[key] === 'function') {\n          //   if (typeof newProps[key] === 'function') {\n          //     fragment.controller.functions.exchange(\n          //       oldProps[key] as Function,\n          //       newProps[key] as Function,\n          //     );\n          //   } else {\n          //     needsUpdate = true;\n          //     fragment.controller.functions.revoke(oldProps[key] as Function);\n          //     updateProps[key] = newProps[key];\n          //   }\n        } else if (oldProps[key] !== newProps[key]) {\n          needsUpdate = true;\n          updateProps[key] = newProps[key];\n        }\n      }\n\n      for (const key in newProps) {\n        if (!has(newProps, key) || key === 'children') {\n          continue;\n        }\n\n        if (!(key in oldProps)) {\n          needsUpdate = true;\n          updateProps[key] = newProps[key];\n        }\n      }\n\n      return needsUpdate ? updateProps : null;\n    },\n\n    commitUpdate(instance, payload) {\n      instance.updateProps(payload);\n    },\n\n    // Update root\n    appendChildToContainer(remoteRoot, child) {\n      remoteRoot.append(child);\n    },\n\n    insertInContainerBefore(remoteRoot, child, beforeChild) {\n      remoteRoot.insertBefore(child, beforeChild);\n    },\n\n    removeChildFromContainer(remoteRoot, child) {\n      remoteRoot.removeChild(child);\n    },\n\n    clearContainer(remoteRoot) {\n      for (const child of remoteRoot.children) {\n        remoteRoot.removeChild(child);\n      }\n    },\n\n    // Update children\n    appendInitialChild(parent, child) {\n      parent.append(child);\n    },\n\n    appendChild(parent, child) {\n      parent.append(child);\n    },\n\n    insertBefore(parent, newChild, beforeChild) {\n      parent.insertBefore(newChild, beforeChild);\n    },\n\n    removeChild(parent, child) {\n      parent.removeChild(child);\n    },\n\n    // Unknown\n    finalizeInitialChildren() {\n      return false;\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    getPublicInstance() {},\n\n    prepareForCommit() {\n      return null;\n    },\n\n    resetAfterCommit() {},\n\n    commitMount() {},\n\n    preparePortalMount() {},\n\n    detachDeletedInstance() {}\n\n  });\n};\n\nfunction scheduleMicrotask(callback) {\n  return typeof queueMicrotask === 'function' ? queueMicrotask : Promise.resolve(null).then(callback).catch(handleErrorInNextTick);\n}\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\nconst {\n  hasOwnProperty\n} = {};\n\nfunction has(object, property) {\n  return hasOwnProperty.call(object, property);\n}\n\nexport { createReconciler };\n", "import { createContext } from 'react';\n\nconst RenderContext = /*#__PURE__*/createContext(null);\n\nexport { RenderContext };\n", "import { memo, useRef, useMemo, isValidElement, Children } from 'react';\nimport { isRemoteFragment } from '@remote-ui/core';\nimport { jsx } from 'react/jsx-runtime';\nimport { useRender } from './hooks/render.mjs';\n\nfunction createRemoteReactComponent(componentType, {\n  fragmentProps\n} = {}) {\n  if (!fragmentProps || !fragmentProps.length) {\n    return componentType;\n  }\n\n  const wrapper = createComponentWrapper(componentType, fragmentProps);\n  wrapper.displayName = componentType;\n  return wrapper;\n}\n\nfunction createComponentWrapper(componentType, fragmentProps) {\n  const Component = componentType;\n  return /*#__PURE__*/memo(function ComponentWrapper({\n    children: externalChildren = [],\n    ...externalProps\n  }) {\n    const fragments = useRef({});\n    const {\n      root,\n      reconciler\n    } = useRender();\n    const {\n      props,\n      children\n    } = useMemo(() => {\n      // React portals need to be attached to the tree after intialize in order to render.\n      // It's usually done by appending them as children of a parent node.\n      // @see https://reactjs.org/docs/portals.html\n      const portals = [];\n      const props = {};\n\n      for (const key of Object.keys(externalProps)) {\n        const element = externalProps[key];\n\n        if (fragmentProps.includes(key) && /*#__PURE__*/isValidElement(element)) {\n          const currentFragment = fragments.current[key];\n          const fragment = isRemoteFragment(currentFragment) ? currentFragment : root.createFragment();\n          fragments.current[key] = fragment; // Assign createText and createComponent to fragment\n          // so that it can become a React container to render the portal\n\n          Object.assign(fragment, {\n            createText(...args) {\n              return root.createText(...args);\n            },\n\n            createComponent(type, ...args) {\n              return root.createComponent(type, ...args);\n            }\n\n          });\n          const portal = reconciler.createPortal(element, fragment, null, null);\n          portals.push(portal);\n          props[key] = fragment;\n        } else {\n          props[key] = element;\n          delete fragments.current[key];\n        }\n      }\n\n      return {\n        props,\n        children: [...Children.toArray(externalChildren), ...portals]\n      };\n    }, [externalChildren, externalProps, root, reconciler, fragments]);\n    return /*#__PURE__*/jsx(Component, { ...props,\n      children: children\n    });\n  });\n}\n\nexport { createRemoteReactComponent };\n", "import { useContext } from 'react';\nimport { RenderContext } from '../context.mjs';\n\nfunction useRender() {\n  const render = useContext(RenderContext);\n\n  if (render == null) {\n    throw new Error('No remote-ui Render instance found in context');\n  }\n\n  return render;\n}\n\nexport { useRender };\n", "import { createContext } from 'react';\n\nconst ExtensionApiContext = /*#__PURE__*/createContext(null);\n\nexport { ExtensionApiContext };\n", "import { Banner as Banner$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Banner = createRemoteReactComponent(Banner$1);\n\nexport { Banner };\n", "import { BlockStack as BlockStack$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst BlockStack = createRemoteReactComponent(BlockStack$1);\n\nexport { BlockStack };\n", "import { Button as Button$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Button = createRemoteReactComponent(Button$1, {\n  fragmentProps: ['overlay']\n});\n\nexport { Button };\n", "import { Divider as Divider$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Divider = createRemoteReactComponent(Divider$1);\n\nexport { Divider };\n", "import { Heading as Heading$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Heading = createRemoteReactComponent(Heading$1);\n\nexport { Heading };\n", "import { Image as Image$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Image = createRemoteReactComponent(Image$1);\n\nexport { Image };\n", "import { InlineStack as InlineStack$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst InlineStack = createRemoteReactComponent(InlineStack$1);\n\nexport { InlineStack };\n", "import { Text as Text$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Text = createRemoteReactComponent(Text$1);\n\nexport { Text };\n", "import { View as View$1 } from '@shopify/ui-extensions/checkout';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst View = createRemoteReactComponent(View$1);\n\nexport { View };\n", "import { useContext } from 'react';\nimport { CheckoutUIExtensionError } from '../errors.mjs';\nimport { ExtensionApiContext } from '../context.mjs';\n\n/**\n * Returns the full API object that was passed in to your extension when it was created.\n * Depending on the extension target, this object can contain different properties.\n *\n * For example, the `purchase.checkout.cart-line-item.render-after` extension target will return the [CartLineDetailsApi](https://shopify.dev/docs/api/checkout-ui-extensions/apis/cartlinedetailsapi) object.\n * Other targets may only have access to the [StandardApi](https://shopify.dev/docs/api/checkout-ui-extensions/apis/standardapi) object,\n * which contains a basic set of properties about the checkout.\n *\n * For a full list of the API available to each extension target, see the [ExtensionTargets type](https://shopify.dev/docs/api/checkout-ui-extensions/apis/extensiontargets).\n */\nfunction useApi(_target) {\n  const api = useContext(ExtensionApiContext);\n  if (api == null) {\n    throw new CheckoutUIExtensionError('You can only call this hook when running as a checkout UI extension.');\n  }\n  return api;\n}\n\n/**\n * Returns the full API object that was passed in to your extension when it was created.\n * Depending on the extension target, this object can contain different properties.\n *\n * For example, the `purchase.checkout.cart-line-item.render-after` extension target will return the [CartLineDetailsApi](https://shopify.dev/docs/api/checkout-ui-extensions/apis/cartlinedetailsapi) object.\n * Other targets may only have access to the [StandardApi](https://shopify.dev/docs/api/checkout-ui-extensions/apis/standardapi) object,\n * which contains a basic set of properties about the checkout.\n *\n * For a full list of the API available to each extension target, see the [ExtensionTargets type](https://shopify.dev/docs/api/checkout-ui-extensions/apis/extensiontargets).\n *\n * > Caution: This is deprecated, use `useApi` instead.\n *\n * @deprecated This is deprecated, use `useApi` instead.\n */\nfunction useExtensionApi() {\n  return useApi();\n}\n\nexport { useApi, useExtensionApi };\n", "class CheckoutUIExtensionError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = 'CheckoutUIExtensionError';\n  }\n}\nclass ScopeNotGrantedError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = 'ScopeNotGrantedError';\n  }\n}\nclass ExtensionHasNoMethodError extends Error {\n  constructor(method, target) {\n    super(`Cannot call '${method}()' on target '${target}'. The corresponding property was not found on the API.`);\n    this.name = 'ExtensionHasNoMethodError';\n  }\n}\nclass ExtensionHasNoTargetError extends Error {\n  constructor(method, target) {\n    super(`Cannot call '${method}()' on target '${target}'. Property 'target' is not found on api.`);\n    this.name = 'ExtensionHasNoTargetError';\n  }\n}\n\nexport { CheckoutUIExtensionError, ExtensionHasNoMethodError, ExtensionHasNoTargetError, ScopeNotGrantedError };\n", "import { useState, useEffect } from 'react';\n\n/**\n * Subscribes to the special wrapper type that all \u201Cchangeable\u201D values in the\n * checkout use. This hook extracts the most recent value from that object,\n * and subscribes to update the value when changes occur in the checkout.\n *\n * > Note:\n * > You generally shouldn\u2019t need to use this directly, as there are dedicated hooks\n * > for accessing the current value of each individual resource in the checkout.\n */\nfunction useSubscription(subscription) {\n  const [, setValue] = useState(subscription.current);\n  useEffect(() => {\n    let didUnsubscribe = false;\n    const checkForUpdates = newValue => {\n      if (didUnsubscribe) {\n        return;\n      }\n      setValue(newValue);\n    };\n    const unsubscribe = subscription.subscribe(checkForUpdates);\n\n    // Because we're subscribing in a passive effect,\n    // it's possible for an update to occur between render and the effect handler.\n    // Check for this and schedule an update if work has occurred.\n    checkForUpdates(subscription.current);\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [subscription]);\n  return subscription.current;\n}\n\nexport { useSubscription };\n", "import { useRef, useEffect } from 'react';\nimport { ExtensionHasNoMethodError } from '../errors.mjs';\nimport { useApi } from './api.mjs';\nimport { useSubscription } from './subscription.mjs';\n\n/**\n * Returns the `buyerJourney` details on buyer progression in checkout.\n */\nfunction useBuyerJourney() {\n  const api = useApi();\n  return api.buyerJourney;\n}\n\n/**\n * Returns true if the buyer completed submitting their order.\n *\n * For example, when viewing the **Order status** page after submitting payment, the buyer will have completed their order.\n */\nfunction useBuyerJourneyCompleted() {\n  const api = useApi();\n  return useSubscription(api.buyerJourney.completed);\n}\n\n/**\n * Installs a function for intercepting and preventing progress on checkout.\n *\n * To block checkout progress, you must set the [block_progress](https://shopify.dev/docs/api/checkout-ui-extensions/configuration#block-progress)\n * capability in your extension's configuration.\n *\n * If you do, then you're expected to inform the buyer why navigation was blocked,\n * either by passing validation errors to the checkout UI or rendering the errors in your extension.\n *\n * `useBuyerJourneyIntercept()` should be called at the top level of the extension,\n * not within an embedded or child component, to avoid errors should the child component get destroyed.\n */\nfunction useBuyerJourneyIntercept(interceptor) {\n  const api = useApi();\n  const interceptorRef = useRef(interceptor);\n  interceptorRef.current = interceptor;\n  return useEffect(() => {\n    const teardownPromise = api.buyerJourney.intercept(interceptorProps => interceptorRef.current(interceptorProps));\n    return () => {\n      teardownPromise.then(teardown => teardown()).catch(() => {});\n    };\n  }, [api.buyerJourney]);\n}\n\n/**\n * Returns all possible steps a buyer can take to complete the checkout. These steps may vary depending on the type of checkout or the shop's configuration.\n */\nfunction useBuyerJourneySteps() {\n  const api = useApi();\n  if (!('buyerJourney' in api) || !api.buyerJourney) {\n    throw new ExtensionHasNoMethodError('buyerJourney', api.extension.target);\n  }\n  return useSubscription(api.buyerJourney.steps);\n}\n\n/**\n * Returns the buyer journey step that the buyer is currently on.\n */\nfunction useBuyerJourneyActiveStep() {\n  const api = useApi();\n  if (!('buyerJourney' in api) || !api.buyerJourney) {\n    throw new ExtensionHasNoMethodError('buyerJourney', api.extension.target);\n  }\n  const steps = useSubscription(api.buyerJourney.steps);\n  const activeStep = useSubscription(api.buyerJourney.activeStep);\n  return activeStep ? steps.find(({\n    handle\n  }) => handle === activeStep.handle) : undefined;\n}\n\nexport { useBuyerJourney, useBuyerJourneyActiveStep, useBuyerJourneyCompleted, useBuyerJourneyIntercept, useBuyerJourneySteps };\n", "import { ExtensionHasNoMethodError } from '../errors.mjs';\nimport { useApi } from './api.mjs';\nimport { useSubscription } from './subscription.mjs';\n\n/**\n * Returns the proposed `attributes` applied to the checkout.\n */\nfunction useAttributes() {\n  return useSubscription(useApi().attributes);\n}\n\n/**\n * Returns the values for the specified `attributes` applied to the checkout.\n *\n * @param keys - An array of attribute keys.\n */\nfunction useAttributeValues(keys) {\n  const attributes = useAttributes();\n  if (!(attributes !== null && attributes !== void 0 && attributes.length)) {\n    return [];\n  }\n  return keys.map(key => {\n    const attribute = attributes.find(attribute => attribute.key === key);\n    return attribute === null || attribute === void 0 ? void 0 : attribute.value;\n  });\n}\n\n/**\n * Returns a function to mutate the `attributes` property of the checkout.\n */\nfunction useApplyAttributeChange() {\n  const api = useApi();\n  if ('applyAttributeChange' in api) {\n    return api.applyAttributeChange;\n  }\n  throw new ExtensionHasNoMethodError('applyAttributeChange', api.extension.target);\n}\n\nexport { useApplyAttributeChange, useAttributeValues, useAttributes };\n", "import { ScopeNotGrantedError, ExtensionHasNoMethodError } from '../errors.mjs';\nimport { useApi } from './api.mjs';\nimport { useSubscription } from './subscription.mjs';\n\n/**\n * Returns the proposed `shippingAddress` applied to the checkout.\n */\nfunction useShippingAddress() {\n  const shippingAddress = useApi().shippingAddress;\n  if (!shippingAddress) {\n    throw new ScopeNotGrantedError('Using shipping address requires having shipping address permissions granted to your app.');\n  }\n  return useSubscription(shippingAddress);\n}\n\n/**\n * Returns a function to mutate the `shippingAddress` property of checkout.\n */\nfunction useApplyShippingAddressChange() {\n  const api = useApi();\n  if ('applyShippingAddressChange' in api) {\n    return api.applyShippingAddressChange;\n  }\n  throw new ExtensionHasNoMethodError('applyShippingAddressChange', api.extension.target);\n}\n\nexport { useApplyShippingAddressChange, useShippingAddress };\n", "import { ExtensionHasNoMethodError } from '../errors.mjs';\nimport { useApi } from './api.mjs';\nimport { useSubscription } from './subscription.mjs';\n\n/**\n * Returns the current line items for the checkout, and automatically re-renders\n * your component if line items are added, removed, or updated.\n */\nfunction useCartLines() {\n  const {\n    lines\n  } = useApi();\n  return useSubscription(lines);\n}\n\n/**\n * Returns a function to mutate the `lines` property of checkout.\n */\nfunction useApplyCartLinesChange() {\n  const api = useApi();\n  if ('applyCartLinesChange' in api) {\n    return api.applyCartLinesChange;\n  }\n  throw new ExtensionHasNoMethodError('applyCartLinesChange', api.extension.target);\n}\n\nexport { useApplyCartLinesChange, useCartLines };\n", "import { useApi } from './api.mjs';\nimport { useSubscription } from './subscription.mjs';\n\n/**\n * Returns the setting values defined by the merchant for the extension.\n */\nfunction useSettings() {\n  const settings = useSubscription(useApi().settings);\n  return settings;\n}\n\nexport { useSettings };\n", "import {\r\n  reactExtension,\r\n  Banner,\r\n  BlockStack,\r\n  Button,\r\n  Divider,\r\n  Heading,\r\n  Image,\r\n  InlineLayout,\r\n  InlineStack,\r\n  Text,\r\n  View,\r\n  useApi,\r\n  useCartLines,\r\n  useShippingAddress,\r\n  useBuyerJourneyIntercept,\r\n  useApplyAttributeChange,\r\n  useSettings,\r\n} from '@shopify/ui-extensions-react/checkout';\r\nimport { useState, useCallback } from 'react';\r\n\r\n// Type for merchant settings\r\ninterface MerchantSettings {\r\n  merchant_payid?: string;\r\n  merchant_name?: string;\r\n  firebase_project_id?: string;\r\n  enable_manual_entry?: boolean;\r\n}\r\n\r\nexport default reactExtension(\r\n  'purchase.checkout.block.render',\r\n  () => <Extension />,\r\n);\r\n\r\nfunction Extension() {\r\n  const { query } = useApi();\r\n  const cartLines = useCartLines();\r\n  const shippingAddress = useShippingAddress();\r\n  const applyAttributeChange = useApplyAttributeChange();\r\n\r\n  // Merchant settings from extension configuration\r\n  const settings = useSettings() as MerchantSettings;\r\n  const merchantPayId = settings.merchant_payid || 'payments@scanandpay.com.au';\r\n  const merchantName = settings.merchant_name || 'Scan & Pay';\r\n  const firebaseProjectId = settings.firebase_project_id || 'scan-and-pay-guihzm';\r\n  const enableManualEntry = settings.enable_manual_entry !== false;\r\n\r\n  // Firebase/Backend Configuration\r\n  const FIREBASE_FUNCTION_URL = `https://australia-southeast1-${firebaseProjectId}.cloudfunctions.net`;\r\n  const GENERATE_QR_URL = `${FIREBASE_FUNCTION_URL}/generatePayIDQR`;\r\n  const VERIFY_PAYMENT_URL = `${FIREBASE_FUNCTION_URL}/verifyPayment`;\r\n  const CHECK_STATUS_URL = `${FIREBASE_FUNCTION_URL}/checkPayIDStatus`;\r\n\r\n  // Payment state\r\n  const [paymentReference, setPaymentReference] = useState('');\r\n  const [qrCodeDataUrl, setQrCodeDataUrl] = useState('');\r\n  const [paymentStatus, setPaymentStatus] = useState('idle'); // idle, pending, paid, failed\r\n  const [showPaymentUI, setShowPaymentUI] = useState(false);\r\n  const [verificationAttempts, setVerificationAttempts] = useState(0);\r\n  const [errorMessage, setErrorMessage] = useState('');\r\n\r\n  // Calculate cart total\r\n  const cartTotal = cartLines.reduce((total, line) => {\r\n    return total + (parseFloat(line.cost.totalAmount.amount) || 0);\r\n  }, 0);\r\n\r\n  // Generate cryptographically secure payment reference\r\n  const generatePaymentReference = useCallback(() => {\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\r\n    const length = 12;\r\n    let reference = 'REF-2024-';\r\n\r\n    // Use crypto for secure random generation\r\n    const array = new Uint8Array(length);\r\n    crypto.getRandomValues(array);\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      reference += chars[array[i] % chars.length];\r\n    }\r\n\r\n    return reference;\r\n  }, []);\r\n\r\n  // Generate NPP-compliant QR code via backend\r\n  const generateQRCode = useCallback(async (payId, amount, reference, merchantName = 'Scan & Pay') => {\r\n    try {\r\n      // Call Firebase Cloud Function to generate NPP-compliant QR code\r\n      const response = await fetch(GENERATE_QR_URL, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          payId: payId,\r\n          amount: amount,\r\n          reference: reference,\r\n          merchantName: merchantName,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`QR generation failed: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n\r\n      // Backend returns QR code as data URL or base64 image\r\n      if (result.qrCodeDataUrl) {\r\n        setQrCodeDataUrl(result.qrCodeDataUrl);\r\n      } else if (result.qrData) {\r\n        // Fallback to displaying QR data as text if image not available\r\n        setQrCodeDataUrl(result.qrData);\r\n      }\r\n    } catch (error) {\r\n      console.error('QR code generation failed:', error);\r\n      setErrorMessage('Failed to generate QR code. Please try again.');\r\n    }\r\n  }, []);\r\n\r\n  // Initialize payment\r\n  const initializePayment = useCallback(async () => {\r\n    const reference = generatePaymentReference();\r\n    setPaymentReference(reference);\r\n\r\n    await generateQRCode(merchantPayId, cartTotal, reference, merchantName);\r\n\r\n    // Store payment reference in checkout attributes\r\n    await applyAttributeChange({\r\n      type: 'updateAttribute',\r\n      key: 'payid_reference',\r\n      value: reference,\r\n    });\r\n\r\n    setShowPaymentUI(true);\r\n  }, [cartTotal, merchantPayId, merchantName, generatePaymentReference, generateQRCode, applyAttributeChange]);\r\n\r\n  // Verify payment with backend (using Global Payments webhook system)\r\n  const verifyPayment = useCallback(async () => {\r\n    if (!paymentReference) return;\r\n\r\n    try {\r\n      setPaymentStatus('pending');\r\n      setVerificationAttempts(prev => prev + 1);\r\n\r\n      // Call verifyPayment endpoint (Terminal 4 API)\r\n      // This queries Global Payments transaction records from webhook data\r\n      const params = new URLSearchParams({\r\n        reference: paymentReference,\r\n        amount: Math.round(cartTotal * 100).toString(), // Convert to cents\r\n        payId: merchantPayId,\r\n      });\r\n\r\n      const response = await fetch(`${VERIFY_PAYMENT_URL}?${params.toString()}`, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Verification failed: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n\r\n      // Backend returns: { status: 'paid' | 'unpaid' | 'pending', transactionId?, amount?, verified? }\r\n      if (result.status === 'paid' && result.verified) {\r\n        // Payment confirmed via Global Payments webhook\r\n        setPaymentStatus('paid');\r\n\r\n        // Store transaction details in checkout attributes\r\n        await applyAttributeChange({\r\n          type: 'updateAttribute',\r\n          key: 'payid_transaction_id',\r\n          value: result.transactionId || paymentReference,\r\n        });\r\n\r\n        await applyAttributeChange({\r\n          type: 'updateAttribute',\r\n          key: 'payid_status',\r\n          value: 'paid',\r\n        });\r\n\r\n        await applyAttributeChange({\r\n          type: 'updateAttribute',\r\n          key: 'payid_amount_cents',\r\n          value: result.amount?.toString() || Math.round(cartTotal * 100).toString(),\r\n        });\r\n\r\n        setErrorMessage('');\r\n      } else if (result.status === 'pending' || result.status === 'unpaid') {\r\n        // Payment not yet received - continue polling\r\n        setPaymentStatus('pending');\r\n\r\n        // Poll again after 3 seconds (max 40 attempts = 2 minutes)\r\n        if (verificationAttempts < 40) {\r\n          setTimeout(() => verifyPayment(), 3000);\r\n        } else {\r\n          setPaymentStatus('failed');\r\n          setErrorMessage('Payment verification timeout. Please contact support if you completed the payment.');\r\n        }\r\n      } else {\r\n        // Payment declined or error\r\n        setPaymentStatus('failed');\r\n        setErrorMessage(result.message || 'Payment not received. Please complete the payment and try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Payment verification error:', error);\r\n      setPaymentStatus('failed');\r\n      setErrorMessage('Verification error. Please try again or contact support.');\r\n    }\r\n  }, [paymentReference, cartTotal, merchantPayId, verificationAttempts, applyAttributeChange, VERIFY_PAYMENT_URL]);\r\n\r\n  // Intercept buyer journey to validate payment\r\n  useBuyerJourneyIntercept(({ canBlockProgress }) => {\r\n    if (!showPaymentUI) {\r\n      // PayID not initiated, allow normal checkout\r\n      return {\r\n        behavior: 'allow',\r\n      };\r\n    }\r\n\r\n    if (paymentStatus === 'paid') {\r\n      // Payment verified, allow order completion\r\n      return {\r\n        behavior: 'allow',\r\n      };\r\n    }\r\n\r\n    if (canBlockProgress && paymentStatus !== 'paid') {\r\n      // Block checkout until payment is verified\r\n      return {\r\n        behavior: 'block',\r\n        reason: 'Please complete PayID payment and verify before continuing.',\r\n        errors: [\r\n          {\r\n            message: 'Payment verification required',\r\n            target: '$.cart',\r\n          },\r\n        ],\r\n      };\r\n    }\r\n\r\n    return {\r\n      behavior: 'allow',\r\n    };\r\n  });\r\n\r\n  // Render payment status indicator\r\n  const renderPaymentStatus = () => {\r\n    if (paymentStatus === 'paid') {\r\n      return (\r\n        <Banner status=\"success\">\r\n          Payment Confirmed! Your order is being processed.\r\n        </Banner>\r\n      );\r\n    }\r\n\r\n    if (paymentStatus === 'pending') {\r\n      return (\r\n        <Banner status=\"warning\">\r\n          Verifying payment... Please wait.\r\n        </Banner>\r\n      );\r\n    }\r\n\r\n    if (paymentStatus === 'failed' && errorMessage) {\r\n      return (\r\n        <Banner status=\"critical\">\r\n          {errorMessage}\r\n        </Banner>\r\n      );\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  if (!showPaymentUI) {\r\n    // Initial state - show PayID option\r\n    return (\r\n      <BlockStack spacing=\"base\">\r\n        <Divider />\r\n        <Heading level={2}>Pay with PayID</Heading>\r\n        <Text>Scan QR code and pay instantly with your bank app</Text>\r\n\r\n        <BlockStack spacing=\"tight\">\r\n          <InlineStack>\r\n            <Text appearance=\"subdued\">Total Amount:</Text>\r\n            <Text emphasis=\"bold\">${cartTotal.toFixed(2)} AUD</Text>\r\n          </InlineStack>\r\n        </BlockStack>\r\n\r\n        <Button kind=\"primary\" onPress={initializePayment}>\r\n          Pay with PayID QR Code\r\n        </Button>\r\n\r\n        <Text size=\"small\" appearance=\"subdued\">\r\n          Secure payment powered by Global Payments Oceania\r\n        </Text>\r\n      </BlockStack>\r\n    );\r\n  }\r\n\r\n  // Payment UI active\r\n  return (\r\n    <BlockStack spacing=\"base\">\r\n      <Divider />\r\n\r\n      {renderPaymentStatus()}\r\n\r\n      <Heading level={2}>PayID Payment</Heading>\r\n\r\n      {/* Payment Details */}\r\n      <View border=\"base\" padding=\"base\" cornerRadius=\"base\">\r\n        <BlockStack spacing=\"tight\">\r\n          <InlineStack>\r\n            <Text appearance=\"subdued\">Amount:</Text>\r\n            <Text emphasis=\"bold\" size=\"large\">\r\n              ${cartTotal.toFixed(2)} AUD\r\n            </Text>\r\n          </InlineStack>\r\n\r\n          <Divider />\r\n\r\n          <BlockStack spacing=\"extraTight\">\r\n            <Text size=\"small\" appearance=\"subdued\">PayID:</Text>\r\n            <Text emphasis=\"bold\">{merchantPayId}</Text>\r\n          </BlockStack>\r\n\r\n          <Divider />\r\n\r\n          <BlockStack spacing=\"extraTight\">\r\n            <Text size=\"small\" appearance=\"subdued\">Payment Reference:</Text>\r\n            <Text emphasis=\"bold\">{paymentReference}</Text>\r\n          </BlockStack>\r\n        </BlockStack>\r\n      </View>\r\n\r\n      {/* QR Code */}\r\n      {qrCodeDataUrl && (\r\n        <View padding=\"base\">\r\n          <BlockStack spacing=\"tight\">\r\n            <Text emphasis=\"bold\">Scan QR Code:</Text>\r\n            <Image source={qrCodeDataUrl} />\r\n          </BlockStack>\r\n        </View>\r\n      )}\r\n\r\n      {/* Instructions */}\r\n      <View border=\"base\" padding=\"base\" cornerRadius=\"base\">\r\n        <BlockStack spacing=\"tight\">\r\n          <Text emphasis=\"bold\">How to Pay:</Text>\r\n          <BlockStack spacing=\"extraTight\">\r\n            <Text size=\"small\">1. Open your banking app</Text>\r\n            <Text size=\"small\">2. Select PayID or Pay Anyone</Text>\r\n            <Text size=\"small\">3. Scan the QR code OR enter details manually</Text>\r\n            <Text size=\"small\">4. Confirm the payment in your bank</Text>\r\n            <Text size=\"small\">5. Click \"I've Paid\" button below</Text>\r\n          </BlockStack>\r\n        </BlockStack>\r\n      </View>\r\n\r\n      {/* Manual Entry Option */}\r\n      {enableManualEntry && (\r\n        <View border=\"base\" padding=\"base\" cornerRadius=\"base\">\r\n          <BlockStack spacing=\"tight\">\r\n            <Text emphasis=\"bold\">Manual Entry:</Text>\r\n            <Text size=\"small\">\r\n              If you can't scan the QR code, enter these details in your banking app:\r\n            </Text>\r\n            <BlockStack spacing=\"extraTight\">\r\n              <Text size=\"small\">PayID: {merchantPayId}</Text>\r\n              <Text size=\"small\">Amount: ${cartTotal.toFixed(2)}</Text>\r\n              <Text size=\"small\">Reference: {paymentReference}</Text>\r\n            </BlockStack>\r\n          </BlockStack>\r\n        </View>\r\n      )}\r\n\r\n      {/* Verification Button */}\r\n      {paymentStatus !== 'paid' && (\r\n        <Button\r\n          kind=\"primary\"\r\n          onPress={verifyPayment}\r\n          loading={paymentStatus === 'pending'}\r\n        >\r\n          {paymentStatus === 'pending' ? 'Verifying...' : \"I've Paid - Verify Now\"}\r\n        </Button>\r\n      )}\r\n\r\n      {paymentStatus === 'paid' && (\r\n        <Banner status=\"success\">\r\n          Payment verified! You can now complete your order.\r\n        </Banner>\r\n      )}\r\n\r\n      {/* Cancel Option */}\r\n      {paymentStatus !== 'paid' && paymentStatus !== 'pending' && (\r\n        <Button onPress={() => setShowPaymentUI(false)}>\r\n          Cancel PayID Payment\r\n        </Button>\r\n      )}\r\n    </BlockStack>\r\n  );\r\n}\r\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\t\toldVNode._dom = oldVNode._parent = null;\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tlet shouldPlace = !!(childVNode._flags & INSERT_VNODE);\n\t\tif (shouldPlace || oldVNode._children === childVNode._children) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom, shouldPlace);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tnewParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @param {boolean} shouldPlace\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom, shouldPlace) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom, shouldPlace);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (shouldPlace) {\n\t\t\tif (oldDom && parentVNode.type && !oldDom.parentNode) {\n\t\t\t\toldDom = getDomSibling(parentVNode);\n\t\t\t}\n\t\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\t}\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\tconst matched = oldVNode != NULL && (oldVNode._flags & MATCHED) == 0;\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren > (matched ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && key == null) ||\n\t\t(matched && key == oldVNode.key && type == oldVNode.type)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tconst childIndex = x >= 0 ? x-- : y++;\n\t\t\toldVNode = oldChildren[childIndex];\n\t\t\tif (\n\t\t\t\toldVNode != NULL &&\n\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\tkey == oldVNode.key &&\n\t\t\t\ttype == oldVNode.type\n\t\t\t) {\n\t\t\t\treturn childIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tnewVNode._original == oldVNode._original ||\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t\tmarkAsForce(newVNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\tif (!e.then) markAsForce(newVNode);\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\nfunction markAsForce(vnode) {\n\tif (vnode && vnode._component) vnode._component._force = true;\n\tif (vnode && vnode._children) vnode._children.forEach(markAsForce);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props || EMPTY_OBJ;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Unwrap potential signals.\n * @param {*} value\n * @returns {*}\n */\nfunction normalizeAttrValue(value) {\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.valueOf === 'function'\n\t\t? value.valueOf()\n\t\t: value;\n}\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tvalue = normalizeAttrValue(value);\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + encodeEntities(str) + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities('' + value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n"],
  "mappings": "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",
  "names": ["require_react_development", "__commonJSMin", "exports", "module", "ReactVersion", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_OFFSCREEN_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "ReactCurrentDispatcher", "ReactCurrentBatchConfig", "ReactCurrentActQueue", "ReactCurrentOwner", "ReactDebugCurrentFrame", "currentExtraStackFrame", "setExtraStackFrame", "stack", "impl", "enableScopeAPI", "enableCacheElement", "enableTransitionTracing", "enableLegacyHidden", "enableDebugTracing", "ReactSharedInternals", "warn", "format", "_len", "args", "_key", "printWarning", "error", "_len2", "_key2", "level", "argsWithFormat", "item", "didWarnStateUpdateForUnmountedComponent", "warnNoop", "publicInstance", "callerName", "_constructor", "componentName", "warningKey", "ReactNoopUpdateQueue", "callback", "completeState", "partialState", "assign", "emptyObject", "Component", "props", "context", "updater", "deprecatedAPIs", "defineDeprecationWarning", "methodName", "info", "fnName", "ComponentDummy", "PureComponent", "pureComponentPrototype", "createRef", "refObject", "isArrayImpl", "isArray", "a", "typeName", "value", "hasToStringTag", "type", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "getComponentNameFromType", "provider", "outerName", "lazyComponent", "payload", "init", "x", "hasOwnProperty", "RESERVED_PROPS", "specialPropKeyWarningShown", "specialPropRefWarningShown", "didWarnAboutStringRefs", "hasValidRef", "config", "getter", "hasValidKey", "defineKeyPropWarningGetter", "warnAboutAccessingKey", "defineRefPropWarningGetter", "warnAboutAccessingRef", "warnIfStringRefCannotBeAutoConverted", "ReactElement", "key", "ref", "self", "source", "owner", "element", "createElement", "children", "propName", "childrenLength", "childArray", "i", "defaultProps", "cloneAndReplaceKey", "oldElement", "newKey", "newElement", "cloneElement", "isValidElement", "object", "SEPARATOR", "SUBSEPARATOR", "escape", "escapeRegex", "escaperLookup", "escapedString", "match", "didWarnAboutMaps", "userProvidedKeyEscapeRegex", "escapeUserProvidedKey", "text", "getElementKey", "index", "mapIntoArray", "array", "escapedPrefix", "nameSoFar", "invokeCallback", "_child", "mappedChild", "childKey", "escapedChildKey", "c", "child", "nextName", "subtreeCount", "nextNamePrefix", "iteratorFn", "iterableChildren", "iterator", "step", "ii", "childrenString", "mapChildren", "func", "result", "count", "countChildren", "n", "forEachChildren", "forEachFunc", "forEachContext", "toArray", "onlyChild", "createContext", "defaultValue", "hasWarnedAboutUsingNestedContextConsumers", "hasWarnedAboutUsingConsumerProvider", "hasWarnedAboutDisplayNameOnConsumer", "Consumer", "_Provider", "_currentValue", "_currentValue2", "_threadCount", "Uninitialized", "Pending", "Resolved", "Rejected", "lazyInitializer", "ctor", "thenable", "moduleObject", "resolved", "rejected", "pending", "lazy", "lazyType", "propTypes", "newDefaultProps", "newPropTypes", "forwardRef", "render", "elementType", "ownName", "name", "REACT_MODULE_REFERENCE", "isValidElementType", "memo", "compare", "resolveDispatcher", "dispatcher", "useContext", "Context", "realContext", "useState", "initialState", "useReducer", "reducer", "initialArg", "useRef", "initialValue", "useEffect", "create", "deps", "useInsertionEffect", "useLayoutEffect", "useCallback", "useMemo", "useImperativeHandle", "useDebugValue", "formatterFn", "useTransition", "useDeferredValue", "useId", "useSyncExternalStore", "subscribe", "getSnapshot", "getServerSnapshot", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "reenableLogs", "ReactCurrentDispatcher$1", "prefix", "describeBuiltInComponentFrame", "ownerFn", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "_frame", "syntheticFrame", "describeFunctionComponentFrame", "shouldConstruct", "prototype", "describeUnknownElementTypeFrameInDEV", "loggedTypeFailures", "ReactDebugCurrentFrame$1", "setCurrentlyValidatingElement", "checkPropTypes", "typeSpecs", "values", "location", "has", "typeSpecName", "error$1", "err", "ex", "setCurrentlyValidatingElement$1", "propTypesMisspellWarningShown", "getDeclarationErrorAddendum", "getSourceInfoErrorAddendum", "fileName", "lineNumber", "getSourceInfoErrorAddendumForProps", "elementProps", "ownerHasKeyUseWarning", "getCurrentComponentErrorInfo", "parentType", "parentName", "validateExplicitKey", "currentComponentErrorInfo", "childOwner", "validateChildKeys", "node", "validatePropTypes", "_name", "validateFragmentProps", "fragment", "keys", "createElementWithValidation", "validType", "sourceInfo", "typeString", "didWarnAboutDeprecatedCreateFactory", "createFactoryWithValidation", "validatedFactory", "cloneElementWithValidation", "startTransition", "scope", "options", "prevTransition", "currentTransition", "updatedFibersCount", "didWarnAboutMessageChannel", "enqueueTaskImpl", "enqueueTask", "task", "requireString", "nodeRequire", "_err", "channel", "actScopeDepth", "didWarnNoAwaitAct", "act", "prevActScopeDepth", "prevIsBatchingLegacy", "queue", "flushActQueue", "popActScope", "thenableResult", "wasAwaited", "resolve", "reject", "returnValue", "recursivelyFlushAsyncActWork", "_queue", "_thenable", "_thenable2", "isFlushing", "createElement$1", "cloneElement$1", "createFactory", "Children", "require_react", "__commonJSMin", "exports", "module", "require_scheduler_development", "__commonJSMin", "exports", "enableSchedulerDebugging", "enableProfiling", "frameYieldMs", "push", "heap", "node", "index", "siftUp", "peek", "pop", "first", "last", "siftDown", "i", "parentIndex", "parent", "compare", "length", "halfLength", "leftIndex", "left", "rightIndex", "right", "a", "b", "diff", "ImmediatePriority", "UserBlockingPriority", "NormalPriority", "LowPriority", "IdlePriority", "markTaskErrored", "task", "ms", "hasPerformanceNow", "localPerformance", "localDate", "initialTime", "maxSigned31BitInt", "IMMEDIATE_PRIORITY_TIMEOUT", "USER_BLOCKING_PRIORITY_TIMEOUT", "NORMAL_PRIORITY_TIMEOUT", "LOW_PRIORITY_TIMEOUT", "IDLE_PRIORITY_TIMEOUT", "taskQueue", "timerQueue", "taskIdCounter", "currentTask", "currentPriorityLevel", "isPerformingWork", "isHostCallbackScheduled", "isHostTimeoutScheduled", "localSetTimeout", "localClearTimeout", "localSetImmediate", "isInputPending", "advanceTimers", "currentTime", "timer", "handleTimeout", "requestHostCallback", "flushWork", "firstTimer", "requestHostTimeout", "hasTimeRemaining", "cancelHostTimeout", "previousPriorityLevel", "workLoop", "error", "shouldYieldToHost", "callback", "didUserCallbackTimeout", "continuationCallback", "unstable_runWithPriority", "priorityLevel", "eventHandler", "unstable_next", "unstable_wrapCallback", "parentPriorityLevel", "unstable_scheduleCallback", "options", "startTime", "delay", "timeout", "expirationTime", "newTask", "unstable_pauseExecution", "unstable_continueExecution", "unstable_getFirstCallbackNode", "unstable_cancelCallback", "unstable_getCurrentPriorityLevel", "isMessageLoopRunning", "scheduledHostCallback", "taskTimeoutID", "frameInterval", "timeElapsed", "requestPaint", "forceFrameRate", "fps", "performWorkUntilDeadline", "hasMoreWork", "schedulePerformWorkUntilDeadline", "channel", "port", "unstable_requestPaint", "unstable_Profiling", "require_scheduler", "__commonJSMin", "exports", "module", "require_react_reconciler_development", "__commonJSMin", "exports", "module", "$$$hostConfig", "React", "Scheduler", "ReactSharedInternals", "suppressWarning", "setSuppressWarning", "newSuppressWarning", "warn", "format", "_len", "args", "_key", "printWarning", "error", "_len2", "_key2", "level", "ReactDebugCurrentFrame", "stack", "argsWithFormat", "item", "assign", "get", "key", "set", "value", "enableNewReconciler", "enableLazyContextPropagation", "enableLegacyHidden", "enableSuspenseAvoidThisFallback", "warnAboutStringRefs", "enableSchedulingProfiler", "enableProfilerTimer", "enableProfilerCommitHooks", "FunctionComponent", "ClassComponent", "IndeterminateComponent", "HostRoot", "HostPortal", "HostComponent", "HostText", "Fragment", "Mode", "ContextConsumer", "ContextProvider", "ForwardRef", "Profiler", "SuspenseComponent", "MemoComponent", "SimpleMemoComponent", "LazyComponent", "IncompleteClassComponent", "DehydratedFragment", "SuspenseListComponent", "ScopeComponent", "OffscreenComponent", "LegacyHiddenComponent", "CacheComponent", "TracingMarkerComponent", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_SCOPE_TYPE", "REACT_DEBUG_TRACING_MODE_TYPE", "REACT_OFFSCREEN_TYPE", "REACT_LEGACY_HIDDEN_TYPE", "REACT_CACHE_TYPE", "REACT_TRACING_MARKER_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "type", "getComponentNameFromType", "context", "provider", "outerName", "lazyComponent", "payload", "init", "x", "getWrappedName$1", "getContextName$1", "getComponentNameFromFiber", "fiber", "tag", "NoFlags", "PerformedWork", "Placement", "Update", "ChildDeletion", "ContentReset", "Callback", "DidCapture", "ForceClientRender", "Ref", "Snapshot", "Passive", "Hydrating", "Visibility", "StoreConsistency", "LifecycleEffectMask", "HostEffectMask", "Incomplete", "ShouldCapture", "ForceUpdateForLegacySuspense", "Forked", "RefStatic", "LayoutStatic", "PassiveStatic", "MountLayoutDev", "MountPassiveDev", "BeforeMutationMask", "MutationMask", "LayoutMask", "PassiveMask", "StaticMask", "ReactCurrentOwner", "getNearestMountedFiber", "node", "nearestMounted", "nextNode", "isFiberMounted", "isMounted", "component", "owner", "ownerFiber", "instance", "assertIsMounted", "findCurrentFiberUsingSlowPath", "alternate", "b", "parentA", "parentB", "nextParent", "child", "didFindChild", "_child", "findCurrentHostFiber", "parent", "currentParent", "findCurrentHostFiberImpl", "match", "findCurrentHostFiberWithNoPortals", "findCurrentHostFiberWithNoPortalsImpl", "isArrayImpl", "isArray", "a", "getPublicInstance", "getRootHostContext", "getChildHostContext", "prepareForCommit", "resetAfterCommit", "createInstance", "appendInitialChild", "finalizeInitialChildren", "prepareUpdate", "shouldSetTextContent", "createTextInstance", "scheduleTimeout", "cancelTimeout", "noTimeout", "isPrimaryRenderer", "warnsIfNotActing", "supportsMutation", "supportsPersistence", "supportsHydration", "getInstanceFromNode", "beforeActiveInstanceBlur", "afterActiveInstanceBlur", "preparePortalMount", "prepareScopeUpdate", "getInstanceFromScope", "getCurrentEventPriority", "detachDeletedInstance", "supportsMicrotasks", "scheduleMicrotask", "supportsTestSelectors", "findFiberRoot", "getBoundingRect", "getTextContent", "isHiddenSubtree", "matchAccessibilityRole", "setFocusIfFocusable", "setupIntersectionObserver", "appendChild", "appendChildToContainer", "commitTextUpdate", "commitMount", "commitUpdate", "insertBefore", "insertInContainerBefore", "removeChild", "removeChildFromContainer", "resetTextContent", "hideInstance", "hideTextInstance", "unhideInstance", "unhideTextInstance", "clearContainer", "cloneInstance", "createContainerChildSet", "appendChildToContainerChildSet", "finalizeContainerChildren", "replaceContainerChildren", "cloneHiddenInstance", "cloneHiddenTextInstance", "canHydrateInstance", "canHydrateTextInstance", "canHydrateSuspenseInstance", "isSuspenseInstancePending", "isSuspenseInstanceFallback", "getSuspenseInstanceFallbackErrorDetails", "registerSuspenseInstanceRetry", "getNextHydratableSibling", "getFirstHydratableChild", "getFirstHydratableChildWithinContainer", "getFirstHydratableChildWithinSuspenseInstance", "hydrateInstance", "hydrateTextInstance", "hydrateSuspenseInstance", "getNextHydratableInstanceAfterSuspenseInstance", "commitHydratedContainer", "commitHydratedSuspenseInstance", "clearSuspenseBoundary", "clearSuspenseBoundaryFromContainer", "shouldDeleteUnhydratedTailInstances", "didNotMatchHydratedContainerTextInstance", "didNotMatchHydratedTextInstance", "didNotHydrateInstanceWithinContainer", "didNotHydrateInstanceWithinSuspenseInstance", "didNotHydrateInstance", "didNotFindHydratableInstanceWithinContainer", "didNotFindHydratableTextInstanceWithinContainer", "didNotFindHydratableSuspenseInstanceWithinContainer", "didNotFindHydratableInstanceWithinSuspenseInstance", "didNotFindHydratableTextInstanceWithinSuspenseInstance", "didNotFindHydratableSuspenseInstanceWithinSuspenseInstance", "didNotFindHydratableInstance", "didNotFindHydratableTextInstance", "didNotFindHydratableSuspenseInstance", "errorHydratingContainer", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "props", "reenableLogs", "ReactCurrentDispatcher", "prefix", "describeBuiltInComponentFrame", "name", "source", "ownerFn", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "c", "_frame", "syntheticFrame", "describeClassComponentFrame", "ctor", "describeFunctionComponentFrame", "shouldConstruct", "Component", "prototype", "describeUnknownElementTypeFrameInDEV", "hasOwnProperty", "loggedTypeFailures", "setCurrentlyValidatingElement", "element", "checkPropTypes", "typeSpecs", "values", "location", "componentName", "has", "typeSpecName", "error$1", "err", "ex", "valueStack", "fiberStack", "index", "createCursor", "defaultValue", "pop", "cursor", "push", "warnedAboutMissingGetChildContext", "emptyContextObject", "contextStackCursor", "didPerformWorkStackCursor", "previousContext", "getUnmaskedContext", "workInProgress", "didPushOwnContextIfProvider", "isContextProvider", "cacheContext", "unmaskedContext", "maskedContext", "getMaskedContext", "contextTypes", "hasContextChanged", "childContextTypes", "popContext", "popTopLevelContextObject", "pushTopLevelContextObject", "didChange", "processChildContext", "parentContext", "childContext", "contextKey", "pushContextProvider", "memoizedMergedChildContext", "invalidateContextProvider", "mergedContext", "findCurrentUnmaskedContext", "LegacyRoot", "ConcurrentRoot", "NoMode", "ConcurrentMode", "ProfileMode", "StrictLegacyMode", "StrictEffectsMode", "clz32", "clz32Fallback", "log", "LN2", "asUint", "TotalLanes", "NoLanes", "NoLane", "SyncLane", "InputContinuousHydrationLane", "InputContinuousLane", "DefaultHydrationLane", "DefaultLane", "TransitionHydrationLane", "TransitionLanes", "TransitionLane1", "TransitionLane2", "TransitionLane3", "TransitionLane4", "TransitionLane5", "TransitionLane6", "TransitionLane7", "TransitionLane8", "TransitionLane9", "TransitionLane10", "TransitionLane11", "TransitionLane12", "TransitionLane13", "TransitionLane14", "TransitionLane15", "TransitionLane16", "RetryLanes", "RetryLane1", "RetryLane2", "RetryLane3", "RetryLane4", "RetryLane5", "SomeRetryLane", "SelectiveHydrationLane", "NonIdleLanes", "IdleHydrationLane", "IdleLane", "OffscreenLane", "getLabelForLane", "lane", "NoTimestamp", "nextTransitionLane", "nextRetryLane", "getHighestPriorityLanes", "lanes", "getHighestPriorityLane", "getNextLanes", "root", "wipLanes", "pendingLanes", "nextLanes", "suspendedLanes", "pingedLanes", "nonIdlePendingLanes", "nonIdleUnblockedLanes", "nonIdlePingedLanes", "unblockedLanes", "nextLane", "wipLane", "entangledLanes", "entanglements", "pickArbitraryLaneIndex", "getMostRecentEventTime", "eventTimes", "mostRecentEventTime", "eventTime", "computeExpirationTime", "currentTime", "markStarvedLanesAsExpired", "expirationTimes", "expirationTime", "getHighestPriorityPendingLanes", "getLanesToRetrySynchronouslyOnError", "everythingButOffscreen", "includesSyncLane", "includesNonIdleWork", "includesOnlyRetries", "includesOnlyNonUrgentLanes", "UrgentLanes", "includesOnlyTransitions", "includesBlockingLane", "SyncDefaultLanes", "includesExpiredLane", "isTransitionLane", "claimNextTransitionLane", "claimNextRetryLane", "pickArbitraryLane", "laneToIndex", "includesSomeLane", "isSubsetOfLanes", "subset", "mergeLanes", "removeLanes", "intersectLanes", "laneToLanes", "higherPriorityLane", "createLaneMap", "initial", "laneMap", "i", "markRootUpdated", "updateLane", "markRootSuspended", "markRootPinged", "markRootFinished", "remainingLanes", "noLongerPendingLanes", "markRootEntangled", "rootEntangledLanes", "getBumpedLaneForHydration", "renderLanes", "renderLane", "addFiberToLanesMap", "isDevToolsPresent", "pendingUpdatersLaneMap", "updaters", "movePendingFibersToMemoized", "memoizedUpdaters", "getTransitionsForLanes", "DiscreteEventPriority", "ContinuousEventPriority", "DefaultEventPriority", "IdleEventPriority", "currentUpdatePriority", "getCurrentUpdatePriority", "setCurrentUpdatePriority", "newPriority", "runWithPriority", "priority", "previousPriority", "higherEventPriority", "lowerEventPriority", "isHigherEventPriority", "lanesToEventPriority", "scheduleCallback", "cancelCallback", "shouldYield", "requestPaint", "now", "ImmediatePriority", "UserBlockingPriority", "NormalPriority", "IdlePriority", "unstable_yieldValue", "unstable_setDisableYieldValue", "rendererID", "injectedHook", "injectedProfilingHooks", "hasLoggedError", "injectInternals", "internals", "hook", "getLaneLabelMap", "injectProfilingHooks", "onScheduleRoot", "children", "onCommitRoot", "eventPriority", "didError", "schedulerPriority", "onPostCommitRoot", "onCommitUnmount", "setIsStrictModeForDevtools", "newIsStrictMode", "profilingHooks", "map", "label", "markCommitStarted", "markCommitStopped", "markComponentRenderStarted", "markComponentRenderStopped", "markComponentPassiveEffectMountStarted", "markComponentPassiveEffectMountStopped", "markComponentPassiveEffectUnmountStarted", "markComponentPassiveEffectUnmountStopped", "markComponentLayoutEffectMountStarted", "markComponentLayoutEffectMountStopped", "markComponentLayoutEffectUnmountStarted", "markComponentLayoutEffectUnmountStopped", "markComponentErrored", "thrownValue", "markComponentSuspended", "wakeable", "markLayoutEffectsStarted", "markLayoutEffectsStopped", "markPassiveEffectsStarted", "markPassiveEffectsStopped", "markRenderStarted", "markRenderYielded", "markRenderStopped", "markRenderScheduled", "markForceUpdateScheduled", "markStateUpdateScheduled", "is", "y", "objectIs", "syncQueue", "includesLegacySyncCallbacks", "isFlushingSyncQueue", "scheduleSyncCallback", "callback", "scheduleLegacySyncCallback", "flushSyncCallbacksOnlyInLegacyMode", "flushSyncCallbacks", "previousUpdatePriority", "isSync", "queue", "isRootDehydrated", "currentState", "forkStack", "forkStackIndex", "treeForkProvider", "treeForkCount", "idStack", "idStackIndex", "treeContextProvider", "treeContextId", "treeContextOverflow", "isForkedChild", "warnIfNotHydrating", "getForksAtLevel", "getTreeId", "overflow", "idWithLeadingBit", "id", "getLeadingBit", "pushTreeFork", "totalChildren", "pushTreeId", "baseIdWithLeadingBit", "baseOverflow", "baseLength", "getBitLength", "baseId", "slot", "length", "numberOfOverflowBits", "newOverflowBits", "newOverflow", "restOfBaseId", "restOfBaseLength", "restOfLength", "restOfNewBits", "newBits", "_id", "_overflow", "pushMaterializedTreeId", "returnFiber", "numberOfForks", "slotIndex", "number", "popTreeContext", "getSuspendedTreeContext", "restoreSuspendedTreeContext", "suspendedContext", "getIsHydrating", "hydrationParentFiber", "nextHydratableInstance", "isHydrating", "didSuspendOrErrorDEV", "hydrationErrors", "warnIfHydrating", "markDidThrowWhileHydratingDEV", "didSuspendOrErrorWhileHydratingDEV", "enterHydrationState", "parentInstance", "reenterHydrationStateFromDehydratedSuspenseInstance", "suspenseInstance", "treeContext", "warnUnhydratedInstance", "isConcurrentMode", "suspenseState", "deleteHydratableInstance", "childToDelete", "createFiberFromHostInstanceForDeletion", "deletions", "warnNonhydratedInstance", "parentContainer", "text", "parentType", "parentProps", "_type", "_props", "_text", "_isConcurrentMode", "_parentInstance", "_type2", "_props2", "_text2", "insertNonHydratedInstance", "tryHydrate", "nextInstance", "textInstance", "dehydratedFragment", "createFiberFromDehydratedFragment", "shouldClientRenderOnMismatch", "throwOnHydrationMismatch", "tryToClaimNextHydratableInstance", "firstAttemptedInstance", "prevHydrationParentFiber", "prepareToHydrateHostInstance", "rootContainerInstance", "hostContext", "shouldWarnIfMismatchDev", "updatePayload", "prepareToHydrateHostTextInstance", "textContent", "shouldUpdate", "_isConcurrentMode2", "prepareToHydrateHostSuspenseInstance", "skipPastDehydratedSuspenseInstance", "popToNextHostParent", "popHydrationState", "warnIfUnhydratedTailNodes", "hasUnhydratedTailNodes", "resetHydrationState", "upgradeHydrationErrorsToRecoverable", "queueRecoverableErrors", "queueHydrationError", "ReactCurrentBatchConfig", "NoTransition", "requestCurrentTransition", "shallowEqual", "objA", "objB", "keysA", "keysB", "currentKey", "describeFiber", "getStackByFiberInDevAndProd", "info", "ReactDebugCurrentFrame$1", "current", "isRendering", "getCurrentFiberOwnerNameInDevOrNull", "getCurrentFiberStackInDev", "resetCurrentFiber", "setCurrentFiber", "getCurrentFiber", "setIsRendering", "rendering", "ReactStrictModeWarnings", "findStrictRoot", "maybeStrictRoot", "setToSortedString", "array", "pendingComponentWillMountWarnings", "pendingUNSAFE_ComponentWillMountWarnings", "pendingComponentWillReceivePropsWarnings", "pendingUNSAFE_ComponentWillReceivePropsWarnings", "pendingComponentWillUpdateWarnings", "pendingUNSAFE_ComponentWillUpdateWarnings", "didWarnAboutUnsafeLifecycles", "componentWillMountUniqueNames", "UNSAFE_componentWillMountUniqueNames", "componentWillReceivePropsUniqueNames", "UNSAFE_componentWillReceivePropsUniqueNames", "componentWillUpdateUniqueNames", "UNSAFE_componentWillUpdateUniqueNames", "sortedNames", "_sortedNames", "_sortedNames2", "_sortedNames3", "_sortedNames4", "_sortedNames5", "pendingLegacyContextWarning", "didWarnAboutLegacyContext", "strictRoot", "warningsForRoot", "fiberArray", "firstFiber", "uniqueNames", "typeName", "hasToStringTag", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "checkPropStringCoercion", "propName", "didWarnAboutMaps", "didWarnAboutGenerators", "didWarnAboutStringRefs", "ownerHasKeyUseWarning", "ownerHasFunctionTypeWarning", "warnForMissingKey", "isReactClass", "coerceRef", "mixedRef", "inst", "resolvedInst", "stringRef", "ref", "refs", "throwOnInvalidObjectType", "newChild", "childString", "warnOnFunctionType", "resolveLazy", "lazyType", "ChildReconciler", "shouldTrackSideEffects", "deleteChild", "deleteRemainingChildren", "currentFirstChild", "mapRemainingChildren", "existingChildren", "existingChild", "useFiber", "pendingProps", "clone", "createWorkInProgress", "placeChild", "newFiber", "lastPlacedIndex", "newIndex", "oldIndex", "placeSingleChild", "updateTextNode", "created", "createFiberFromText", "existing", "updateElement", "elementType", "updateFragment", "isCompatibleFamilyForHotReloading", "createFiberFromElement", "updatePortal", "portal", "createFiberFromPortal", "fragment", "createFiberFromFragment", "createChild", "_created", "_created2", "_created3", "updateSlot", "oldFiber", "updateFromMap", "newIdx", "matchedFiber", "_matchedFiber", "_matchedFiber2", "_matchedFiber3", "warnOnInvalidKey", "knownKeys", "reconcileChildrenArray", "newChildren", "resultingFirstChild", "previousNewFiber", "nextOldFiber", "_newFiber", "_numberOfForks", "_newFiber2", "_numberOfForks2", "reconcileChildrenIterator", "newChildrenIterable", "iteratorFn", "_newChildren", "_step", "step", "_newFiber3", "_numberOfForks3", "_newFiber4", "_numberOfForks4", "reconcileSingleTextNode", "reconcileSingleElement", "_existing", "_created4", "reconcileSinglePortal", "reconcileChildFibers", "isUnkeyedTopLevelFragment", "mountChildFibers", "cloneChildFibers", "currentChild", "resetChildFibers", "resetWorkInProgress", "valueCursor", "rendererSigil", "currentlyRenderingFiber", "lastContextDependency", "lastFullyObservedContext", "isDisallowedContextReadInDEV", "resetContextDependencies", "enterDisallowedContextReadInDEV", "exitDisallowedContextReadInDEV", "pushProvider", "providerFiber", "nextValue", "popProvider", "currentValue", "scheduleContextWorkOnParentPath", "propagationRoot", "propagateContextChange", "propagateContextChange_eager", "nextFiber", "list", "dependency", "update", "createUpdate", "ForceUpdate", "updateQueue", "sharedQueue", "pending", "parentSuspense", "_alternate", "sibling", "prepareToReadContext", "dependencies", "firstContext", "markWorkInProgressReceivedUpdate", "readContext", "contextItem", "concurrentQueues", "pushConcurrentUpdateQueue", "finishQueueingConcurrentUpdates", "lastInterleavedUpdate", "firstInterleavedUpdate", "lastPendingUpdate", "firstPendingUpdate", "enqueueConcurrentHookUpdate", "interleaved", "markUpdateLaneFromFiberToRoot", "enqueueConcurrentHookUpdateAndEagerlyBailout", "enqueueConcurrentClassUpdate", "enqueueConcurrentRenderForLane", "unsafe_markUpdateLaneFromFiberToRoot", "sourceFiber", "warnAboutUpdateOnNotYetMountedFiberInDEV", "UpdateState", "ReplaceState", "CaptureUpdate", "hasForceUpdate", "didWarnUpdateInsideUpdate", "currentlyProcessingQueue", "initializeUpdateQueue", "cloneUpdateQueue", "currentQueue", "enqueueUpdate", "isUnsafeClassRenderPhaseUpdate", "entangleTransitions", "queueLanes", "newQueueLanes", "enqueueCapturedUpdate", "capturedUpdate", "newFirst", "newLast", "firstBaseUpdate", "lastBaseUpdate", "getStateFromUpdate", "prevState", "nextProps", "nextState", "_payload", "partialState", "processUpdateQueue", "pendingQueue", "currentLastBaseUpdate", "newState", "newLanes", "newBaseState", "newFirstBaseUpdate", "newLastBaseUpdate", "updateEventTime", "_clone", "effects", "_lastPendingUpdate", "_firstPendingUpdate", "lastInterleaved", "markSkippedUpdateLanes", "callCallback", "resetHasForceUpdateBeforeProcessing", "checkHasForceUpdateAfterProcessing", "commitUpdateQueue", "finishedWork", "finishedQueue", "effect", "NO_CONTEXT", "contextStackCursor$1", "contextFiberStackCursor", "rootInstanceStackCursor", "requiredContext", "getRootHostContainer", "rootInstance", "pushHostContainer", "nextRootInstance", "nextRootContext", "popHostContainer", "getHostContext", "pushHostContext", "nextContext", "popHostContext", "DefaultSuspenseContext", "SubtreeSuspenseContextMask", "InvisibleParentSuspenseContext", "ForceSuspenseFallback", "suspenseStackCursor", "hasSuspenseContext", "flag", "setDefaultShallowSuspenseContext", "setShallowSuspenseContext", "shallowContext", "addSubtreeSuspenseContext", "subtreeContext", "pushSuspenseContext", "newContext", "popSuspenseContext", "shouldCaptureSuspense", "hasInvisibleParent", "findFirstSuspended", "row", "state", "dehydrated", "didSuspend", "NoFlags$1", "HasEffect", "Insertion", "Layout", "Passive$1", "workInProgressSources", "resetWorkInProgressVersions", "mutableSource", "registerMutableSourceForHydration", "getVersion", "version", "ReactCurrentDispatcher$1", "ReactCurrentBatchConfig$1", "didWarnAboutMismatchedHooksForComponent", "didWarnUncachedGetSnapshot", "currentlyRenderingFiber$1", "currentHook", "workInProgressHook", "didScheduleRenderPhaseUpdate", "didScheduleRenderPhaseUpdateDuringThisPass", "localIdCounter", "globalClientIdCounter", "RE_RENDER_LIMIT", "currentHookNameInDev", "hookTypesDev", "hookTypesUpdateIndexDev", "ignorePreviousDependencies", "mountHookTypesDev", "hookName", "updateHookTypesDev", "warnOnHookMismatchInDev", "checkDepsAreArrayDev", "deps", "currentHookName", "table", "secondColumnStart", "oldHookName", "newHookName", "throwInvalidHookError", "areHookInputsEqual", "nextDeps", "prevDeps", "renderWithHooks", "secondArg", "nextRenderLanes", "HooksDispatcherOnUpdateInDEV", "HooksDispatcherOnMountWithHookTypesInDEV", "HooksDispatcherOnMountInDEV", "numberOfReRenders", "HooksDispatcherOnRerenderInDEV", "ContextOnlyDispatcher", "didRenderTooFewHooks", "checkDidRenderIdHook", "didRenderIdHook", "bailoutHooks", "resetHooksAfterThrow", "isUpdatingOpaqueValueInRenderPhase", "mountWorkInProgressHook", "updateWorkInProgressHook", "nextCurrentHook", "nextWorkInProgressHook", "newHook", "createFunctionComponentUpdateQueue", "basicStateReducer", "action", "mountReducer", "reducer", "initialArg", "initialState", "dispatch", "dispatchReducerAction", "updateReducer", "baseQueue", "baseFirst", "pendingFirst", "first", "newBaseQueueFirst", "newBaseQueueLast", "interleavedLane", "rerenderReducer", "lastRenderPhaseUpdate", "firstRenderPhaseUpdate", "mountMutableSource", "getSnapshot", "subscribe", "updateMutableSource", "mountSyncExternalStore", "getServerSnapshot", "nextSnapshot", "cachedSnapshot", "getWorkInProgressRoot", "pushStoreConsistencyCheck", "mountEffect", "subscribeToStore", "pushEffect", "updateStoreInstance", "updateSyncExternalStore", "prevSnapshot", "snapshotChanged", "updateEffect", "renderedSnapshot", "check", "componentUpdateQueue", "stores", "checkIfSnapshotChanged", "forceStoreRerender", "handleStoreChange", "latestGetSnapshot", "prevValue", "scheduleUpdateOnFiber", "mountState", "dispatchSetState", "updateState", "rerenderState", "create", "destroy", "lastEffect", "firstEffect", "mountRef", "initialValue", "_ref2", "updateRef", "mountEffectImpl", "fiberFlags", "hookFlags", "updateEffectImpl", "prevEffect", "mountInsertionEffect", "updateInsertionEffect", "mountLayoutEffect", "updateLayoutEffect", "imperativeHandleEffect", "refCallback", "_inst", "refObject", "_inst2", "mountImperativeHandle", "effectDeps", "updateImperativeHandle", "mountDebugValue", "formatterFn", "updateDebugValue", "mountCallback", "updateCallback", "mountMemo", "nextCreate", "updateMemo", "mountDeferredValue", "updateDeferredValue", "resolvedCurrentHook", "updateDeferredValueImpl", "rerenderDeferredValue", "shouldDeferValue", "deferredLane", "startTransition", "setPending", "options", "prevTransition", "currentTransition", "updatedFibersCount", "mountTransition", "_mountState", "isPending", "start", "updateTransition", "_updateState", "rerenderTransition", "_rerenderState", "getIsUpdatingOpaqueValueInRenderPhaseInDEV", "mountId", "identifierPrefix", "treeId", "localId", "globalClientId", "updateId", "requestUpdateLane", "isRenderPhaseUpdate", "enqueueRenderPhaseUpdate", "requestEventTime", "entangleTransitionUpdate", "markUpdateInDevTools", "lastRenderedReducer", "prevDispatcher", "InvalidNestedHooksDispatcherOnUpdateInDEV", "eagerState", "InvalidNestedHooksDispatcherOnMountInDEV", "InvalidNestedHooksDispatcherOnRerenderInDEV", "warnInvalidContextAccess", "warnInvalidHookAccess", "now$1", "commitTime", "layoutEffectStartTime", "profilerStartTime", "passiveEffectStartTime", "currentUpdateIsNested", "nestedUpdateScheduled", "isCurrentUpdateNested", "markNestedUpdateScheduled", "resetNestedUpdateFlag", "syncNestedUpdateFlag", "getCommitTime", "recordCommitTime", "startProfilerTimer", "stopProfilerTimerIfRunning", "stopProfilerTimerIfRunningAndRecordDelta", "overrideBaseTime", "elapsedTime", "recordLayoutEffectDuration", "parentFiber", "parentStateNode", "recordPassiveEffectDuration", "startLayoutEffectTimer", "startPassiveEffectTimer", "transferActualDuration", "resolveDefaultProps", "baseProps", "defaultProps", "fakeInternalInstance", "didWarnAboutStateAssignmentForComponent", "didWarnAboutUninitializedState", "didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate", "didWarnAboutLegacyLifecyclesAndDerivedState", "didWarnAboutUndefinedDerivedState", "warnOnUndefinedDerivedState", "warnOnInvalidCallback", "didWarnAboutDirectlyAssigningPropsToState", "didWarnAboutContextTypeAndContextTypes", "didWarnAboutInvalidateContextType", "didWarnAboutLegacyContext$1", "didWarnOnInvalidCallback", "callerName", "applyDerivedStateFromProps", "getDerivedStateFromProps", "memoizedState", "classComponentUpdater", "checkShouldComponentUpdate", "oldProps", "newProps", "oldState", "checkClassInstance", "renderPresent", "hasMutatedProps", "_state", "adoptClassInstance", "constructClassInstance", "isLegacyContextConsumer", "contextType", "isValid", "addendum", "foundWillMountName", "foundWillReceivePropsName", "foundWillUpdateName", "_componentName", "newApiName", "callComponentWillMount", "callComponentWillReceiveProps", "mountClassInstance", "resumeMountClassInstance", "oldContext", "nextLegacyUnmaskedContext", "hasNewLifecycles", "_fiberFlags", "_fiberFlags2", "updateClassInstance", "unresolvedOldProps", "unresolvedNewProps", "nextUnmaskedContext", "createCapturedValueAtFiber", "createCapturedValue", "digest", "showErrorDialog", "boundary", "errorInfo", "logCapturedError", "logError", "componentStack", "componentNameMessage", "errorBoundaryMessage", "errorBoundaryName", "combinedMessage", "PossiblyWeakMap$1", "createRootErrorUpdate", "onUncaughtError", "createClassErrorUpdate", "getDerivedStateFromError", "markFailedErrorBoundaryForHotReloading", "markLegacyErrorBoundaryAsFailed", "attachPingListener", "pingCache", "threadIDs", "ping", "pingSuspendedRoot", "restorePendingUpdaters", "attachRetryListener", "suspenseBoundary", "wakeables", "resetSuspendedComponent", "rootRenderLanes", "currentSource", "getNearestSuspenseBoundaryToCapture", "markSuspenseBoundaryShouldCapture", "currentSourceFiber", "throwException", "renderDidSuspendDelayIfPossible", "uncaughtSuspenseError", "_suspenseBoundary", "renderDidError", "_errorInfo", "isAlreadyFailedLegacyErrorBoundary", "_lane", "_update", "getSuspendedCache", "ReactCurrentOwner$1", "didReceiveUpdate", "didWarnAboutBadClass", "didWarnAboutModulePatternComponent", "didWarnAboutContextTypeOnFunctionComponent", "didWarnAboutGetDerivedStateOnFunctionComponent", "didWarnAboutFunctionRefs", "didWarnAboutReassigningProps", "didWarnAboutRevealOrder", "didWarnAboutTailOptions", "didWarnAboutDefaultPropsOnFunctionComponent", "reconcileChildren", "nextChildren", "forceUnmountCurrentAndReconcile", "updateForwardRef", "innerPropTypes", "render", "hasId", "bailoutOnAlreadyFinishedWork", "updateMemoComponent", "isSimpleFunctionComponent", "resolvedType", "resolveFunctionForHotReloading", "validateFunctionComponentInDev", "updateSimpleMemoComponent", "createFiberFromTypeAndProps", "_innerPropTypes", "hasScheduledUpdateOrContext", "checkScheduledUpdateOrContext", "prevProps", "compare", "outerMemoType", "outerPropTypes", "updateFunctionComponent", "updateOffscreenComponent", "pushRenderLanes", "_nextState2", "subtreeRenderLanes", "spawnedCachePool", "nextBaseLanes", "prevBaseLanes", "_nextState", "_subtreeRenderLanes", "updateMode", "updateProfiler", "stateNode", "markRef", "updateClassComponent", "shouldError", "_instance", "tempInstance", "hasContext", "resetSuspendedCurrentOnMountInLegacyMode", "nextUnitOfWork", "finishClassComponent", "didCaptureError", "pushHostRootContext", "updateHostRoot", "prevChildren", "overrideState", "recoverableError", "mountHostRootWithoutHydrating", "_recoverableError", "updateHostComponent", "isDirectTextChild", "updateHostText", "mountLazyComponent", "_current", "resolvedTag", "resolveLazyComponentTag", "resolvedProps", "resolveClassForHotReloading", "resolveForwardRefForHotReloading", "hint", "mountIncompleteClassComponent", "mountIndeterminateComponent", "_componentName2", "ownerName", "warningKey", "debugSource", "_componentName3", "_componentName4", "SUSPENDED_MARKER", "mountSuspenseOffscreenState", "updateSuspenseOffscreenState", "prevOffscreenState", "cachePool", "shouldRemainOnFallback", "suspenseContext", "getRemainingWorkInPrimaryTree", "updateSuspenseComponent", "shouldSuspend", "showFallback", "mountDehydratedSuspenseComponent", "nextPrimaryChildren", "nextFallbackChildren", "fallbackFragment", "mountSuspenseFallbackChildren", "primaryChildFragment", "mountSuspensePrimaryChildren", "_dehydrated", "updateDehydratedSuspenseComponent", "_nextFallbackChildren", "_nextPrimaryChildren", "fallbackChildFragment", "updateSuspenseFallbackChildren", "_primaryChildFragment2", "_nextPrimaryChildren2", "_primaryChildFragment3", "updateSuspensePrimaryChildren", "primaryChildren", "mode", "primaryChildProps", "mountWorkInProgressOffscreenFiber", "fallbackChildren", "progressedPrimaryFragment", "offscreenProps", "createFiberFromOffscreen", "updateWorkInProgressOffscreenFiber", "currentPrimaryChildFragment", "currentFallbackChildFragment", "retrySuspenseComponentWithoutHydrating", "mountSuspenseFallbackAfterRetryWithoutHydrating", "fiberMode", "_capturedValue2", "_primaryChildFragment4", "message", "_getSuspenseInstanceF", "capturedValue", "attemptHydrationAtLane", "_capturedValue", "retry", "retryDehydratedSuspenseBoundary", "scheduleSuspenseWorkOnFiber", "propagateSuspenseContextChange", "firstChild", "findLastContentRow", "lastContentRow", "currentRow", "validateRevealOrder", "revealOrder", "validateTailOptions", "tailMode", "validateSuspenseListNestedChild", "childSlot", "isAnArray", "isIterable", "validateSuspenseListChildren", "childrenIterator", "_i", "initSuspenseListRenderState", "isBackwards", "tail", "renderState", "updateSuspenseListComponent", "shouldForceFallback", "didSuspendBefore", "_tail", "nextRow", "updatePortalComponent", "hasWarnedAboutUsingNoValuePropOnContextProvider", "updateContextProvider", "providerType", "newValue", "providerPropTypes", "oldValue", "hasWarnedAboutUsingContextAsConsumer", "updateContextConsumer", "remountFiber", "oldWorkInProgress", "newWorkInProgress", "prevSibling", "updateLanes", "attemptEarlyBailoutIfNoScheduledUpdate", "hasChildWork", "primaryChildLanes", "_hasChildWork", "beginWork", "unresolvedProps", "_Component", "_unresolvedProps", "_resolvedProps", "_unresolvedProps2", "_resolvedProps2", "_unresolvedProps3", "_resolvedProps3", "_Component2", "_unresolvedProps4", "_resolvedProps4", "markUpdate", "markRef$1", "hadNoMutationsEffects", "completedWork", "didBailout", "appendAllChildren", "updateHostContainer", "updateHostComponent$1", "updateHostText$1", "needsVisibilityToggle", "isHidden", "currentHostContext", "oldText", "newText", "appendAllChildrenToContainer", "containerChildSet", "_instance2", "portalOrRoot", "childrenUnchanged", "container", "newChildSet", "currentInstance", "recyclableInstance", "newInstance", "cutOffTailIfNeeded", "hasRenderedATailFallback", "tailNode", "lastTailNode", "_tailNode", "_lastTailNode", "bubbleProperties", "newChildLanes", "subtreeFlags", "_treeBaseDuration", "_child2", "_child3", "actualDuration", "treeBaseDuration", "completeDehydratedSuspenseBoundary", "wasHydrated", "isTimedOutSuspense", "_isTimedOutSuspense", "_primaryChildFragment", "completeWork", "fiberRoot", "_wasHydrated", "_rootContainerInstance", "_currentHostContext", "_wasHydrated2", "fallthroughToNormalSuspensePath", "nextDidTimeout", "prevDidTimeout", "_offscreenFiber2", "hasInvisibleChildContext", "renderDidSuspend", "didSuspendAlready", "renderedTail", "cannotBeSuspended", "renderHasNotSuspendedYet", "suspended", "newThenables", "getRenderTargetTime", "_suspended", "_newThenables", "previousSibling", "next", "popRenderLanes", "nextIsHidden", "_prevState", "prevIsHidden", "unwindWork", "flags", "_flags", "_flags2", "unwindInterruptedWork", "interruptedWork", "invokeGuardedCallbackProd", "func", "d", "funcArgs", "invokeGuardedCallbackImpl", "fakeNode", "f", "evt", "didCall", "windowEvent", "windowEventDescriptor", "restoreAfterDispatch", "evtType", "didSetError", "isCrossOriginError", "handleWindowError", "event", "inner", "invokeGuardedCallbackImpl$1", "hasError", "caughtError", "reporter", "invokeGuardedCallback", "hasCaughtError", "clearCaughtError", "didWarnAboutUndefinedSnapshotBeforeUpdate", "offscreenSubtreeIsHidden", "offscreenSubtreeWasHidden", "PossiblyWeakSet", "nextEffect", "inProgressLanes", "inProgressRoot", "reportUncaughtErrorInDEV", "callComponentWillUnmountWithTimer", "safelyCallCommitHookLayoutEffectListMount", "nearestMountedAncestor", "commitHookEffectListMount", "captureCommitPhaseError", "safelyCallComponentWillUnmount", "safelyCallComponentDidMount", "safelyAttachRef", "commitAttachRef", "safelyDetachRef", "retVal", "safelyCallDestroy", "focusedInstanceHandle", "shouldFireAfterActiveInstanceBlur", "commitBeforeMutationEffects", "commitBeforeMutationEffects_begin", "shouldFire", "commitBeforeMutationEffects_complete", "commitBeforeMutationEffectsOnFiber", "snapshot", "didWarnSet", "commitHookEffectListUnmount", "setIsRunningInsertionEffect", "commitPassiveEffectDurations", "finishedRoot", "passiveEffectDuration", "_finishedWork$memoize", "onPostCommit", "phase", "outer", "commitLayoutEffectOnFiber", "committedLanes", "_updateQueue", "_finishedWork$memoize2", "onCommit", "onRender", "effectDuration", "enqueuePendingPassiveProfilerEffect", "commitSuspenseHydrationCallbacks", "reappearLayoutEffectsOnFiber", "hideOrUnhideAllChildren", "hostSubtreeRoot", "_instance3", "instanceToUse", "detachFiberMutation", "detachFiberAfterEffects", "hostInstance", "emptyPortalContainer", "containerInfo", "emptyChildSet", "getHostParentFiber", "isHostParent", "getHostSibling", "siblings", "commitPlacement", "before", "insertOrAppendPlacementNode", "_parent", "_before", "insertOrAppendPlacementNodeIntoContainer", "isHost", "hostParent", "hostParentIsContainer", "commitDeletionEffects", "deletedFiber", "findParent", "commitDeletionEffectsOnFiber", "recursivelyTraverseDeletionEffects", "prevHostParent", "prevHostParentIsContainer", "_prevHostParent", "_prevHostParentIsContainer", "_effect", "prevOffscreenSubtreeWasHidden", "commitSuspenseCallback", "attachSuspenseRetryListeners", "retryCache", "resolveRetryWakeable", "commitMutationEffects", "commitMutationEffectsOnFiber", "recursivelyTraverseMutationEffects", "prevDebugFiber", "commitReconciliationEffects", "_instance4", "prevRootState", "pendingChildren", "_containerInfo", "_pendingChildren", "offscreenFiber", "offscreenInstance", "wasHidden", "markCommitTimeOfFallback", "_wasHidden", "_offscreenInstance", "_newState", "_isHidden", "offscreenBoundary", "offscreenChild", "disappearLayoutEffects_begin", "commitLayoutEffects", "commitLayoutEffects_begin", "subtreeRoot", "isModernRoot", "newOffscreenSubtreeIsHidden", "commitLayoutMountEffects_complete", "newOffscreenSubtreeWasHidden", "prevOffscreenSubtreeIsHidden", "reappearLayoutEffects_begin", "disappearLayoutEffects_complete", "reappearLayoutEffects_complete", "commitPassiveMountEffects", "committedTransitions", "commitPassiveMountEffects_begin", "commitPassiveMountEffects_complete", "commitPassiveMountOnFiber", "commitPassiveUnmountEffects", "commitPassiveUnmountEffects_begin", "fiberToDelete", "commitPassiveUnmountEffectsInsideOfDeletedTree_begin", "previousFiber", "detachedChild", "detachedSibling", "commitPassiveUnmountEffects_complete", "commitPassiveUnmountOnFiber", "deletedSubtreeRoot", "commitPassiveUnmountInsideDeletedTreeOnFiber", "commitPassiveUnmountEffectsInsideOfDeletedTree_complete", "invokeLayoutEffectMountInDEV", "invokePassiveEffectMountInDEV", "invokeLayoutEffectUnmountInDEV", "invokePassiveEffectUnmountInDEV", "COMPONENT_TYPE", "HAS_PSEUDO_CLASS_TYPE", "ROLE_TYPE", "TEST_NAME_TYPE", "TEXT_TYPE", "symbolFor", "createComponentSelector", "createHasPseudoClassSelector", "selectors", "createRoleSelector", "role", "createTextSelector", "createTestNameSelector", "findFiberRootForHostRoot", "hostRoot", "maybeFiber", "matchSelector", "selector", "hasMatchingPaths", "dataTestID", "selectorToString", "findPaths", "matchingFibers", "selectorIndex", "findAllNodes", "instanceRoots", "getFindAllNodesFailureDescription", "maxSelectorIndex", "matchedNames", "unmatchedNames", "findBoundingRects", "boundingRects", "targetRect", "targetLeft", "targetRight", "targetTop", "targetBottom", "j", "otherRect", "otherLeft", "otherRight", "otherTop", "otherBottom", "focusWithin", "commitHooks", "onCommitRoot$1", "commitHook", "observeVisibleRects", "_setupIntersectionObs", "disconnect", "observe", "unobserve", "nextInstanceRoots", "target", "ReactCurrentActQueue", "isLegacyActEnvironment", "isReactActEnvironmentGlobal", "jestIsDefined", "isConcurrentActEnvironment", "ceil", "ReactCurrentDispatcher$2", "ReactCurrentOwner$2", "ReactCurrentBatchConfig$2", "ReactCurrentActQueue$1", "NoContext", "BatchedContext", "RenderContext", "CommitContext", "RootInProgress", "RootFatalErrored", "RootErrored", "RootSuspended", "RootSuspendedWithDelay", "RootCompleted", "RootDidNotComplete", "executionContext", "workInProgressRoot", "workInProgressRootRenderLanes", "subtreeRenderLanesCursor", "workInProgressRootExitStatus", "workInProgressRootFatalError", "workInProgressRootIncludedLanes", "workInProgressRootSkippedLanes", "workInProgressRootInterleavedUpdatedLanes", "workInProgressRootPingedLanes", "workInProgressRootConcurrentErrors", "workInProgressRootRecoverableErrors", "globalMostRecentFallbackTime", "FALLBACK_THROTTLE_MS", "workInProgressRootRenderTargetTime", "RENDER_TIMEOUT_MS", "workInProgressTransitions", "resetRenderTimer", "hasUncaughtError", "firstUncaughtError", "legacyErrorBoundariesThatAlreadyFailed", "rootDoesHavePassiveEffects", "rootWithPendingPassiveEffects", "pendingPassiveEffectsLanes", "pendingPassiveProfilerEffects", "pendingPassiveTransitions", "NESTED_UPDATE_LIMIT", "nestedUpdateCount", "rootWithNestedUpdates", "isFlushingPassiveEffects", "didScheduleUpdateDuringPassiveEffects", "NESTED_PASSIVE_UPDATE_LIMIT", "nestedPassiveUpdateCount", "rootWithPassiveNestedUpdates", "currentEventTime", "currentEventTransitionLane", "isRunningInsertionEffect", "isTransition", "transition", "eventLane", "requestRetryLane", "checkForNestedUpdates", "warnAboutRenderPhaseUpdatesInDEV", "warnIfUpdatesNotWrappedWithActDEV", "markRootSuspended$1", "ensureRootIsScheduled", "scheduleInitialHydrationOnRoot", "existingCallbackNode", "cancelCallback$1", "newCallbackPriority", "existingCallbackPriority", "fakeActCallbackNode", "newCallbackNode", "performSyncWorkOnRoot", "scheduleCallback$1", "schedulerPriorityLevel", "performConcurrentWorkOnRoot", "didTimeout", "originalCallbackNode", "didFlushPassiveEffects", "flushPassiveEffects", "shouldTimeSlice", "exitStatus", "renderRootConcurrent", "renderRootSync", "errorRetryLanes", "recoverFromConcurrentError", "fatalError", "prepareFreshStack", "renderWasConcurrent", "isRenderConsistentWithExternalStores", "_errorRetryLanes", "_fatalError", "finishConcurrentRender", "errorsFromFirstAttempt", "rootWorkInProgress", "errorsFromSecondAttempt", "errors", "commitRoot", "shouldForceFlushFallbacksInDEV", "msUntilTimeout", "eventTimeMs", "timeElapsedMs", "_msUntilTimeout", "jnd", "checks", "renderedValue", "flushRoot", "deferredUpdates", "batchedUpdates", "prevExecutionContext", "discreteUpdates", "flushSync", "isAlreadyRendering", "flushControlled", "timeoutHandle", "handleError", "erroredWork", "completeUnitOfWork", "yetAnotherThrownValue", "pushDispatcher", "popDispatcher", "workLoopSync", "performUnitOfWork", "workLoopConcurrent", "unitOfWork", "beginWork$1", "_next", "siblingFiber", "recoverableErrors", "transitions", "previousUpdateLanePriority", "commitRootImpl", "renderPriorityLevel", "flushRenderPhaseStrictModeWarningsInDEV", "subtreeHasEffects", "rootHasEffect", "rootDidHavePassiveEffects", "commitDoubleInvokeEffectsInDEV", "onRecoverableError", "renderPriority", "flushPassiveEffectsImpl", "profilerEffects", "_fiber", "prepareToThrowUncaughtError", "captureCommitPhaseErrorOnRoot", "rootFiber", "warnIfSuspenseResolutionNotWrappedWithActDEV", "retryTimedOutBoundary", "boundaryFiber", "retryLane", "timeElapsed", "hasPassiveEffects", "invokeEffectsInDev", "invokeEffectFn", "primarySubtreeFlag", "didWarnStateUpdateForNotYetMountedComponent", "dummyFiber", "originalWorkInProgressCopy", "assignFiberPropertiesInDEV", "originalError", "replayError", "didWarnAboutUpdateInRender", "didWarnAboutUpdateInRenderForAnotherComponent", "renderingComponentName", "dedupeKey", "setStateComponentName", "schedulingFiber", "priorityLevel", "actQueue", "callbackNode", "isRunning", "resolveFamily", "failedBoundaries", "setRefreshHandler", "handler", "family", "currentRender", "syntheticType", "prevType", "nextType", "needsCompareFamilies", "$$typeofNextType", "prevFamily", "scheduleRefresh", "staleFamilies", "updatedFamilies", "scheduleFibersWithFamiliesRecursively", "scheduleRoot", "updateContainer", "candidateType", "needsRender", "needsRemount", "_root", "findHostInstancesForRefresh", "families", "hostInstances", "types", "findHostInstancesForMatchingFibersRecursively", "didMatch", "findHostInstancesForFiberShallowly", "foundHostInstances", "findChildHostInstancesForFiberShallowly", "hasBadMapPolyfill", "nonExtensibleObject", "FiberNode", "createFiber", "shouldConstruct$1", "$$typeof", "currentDependencies", "createHostRootFiber", "isStrictMode", "concurrentUpdatesByDefaultOverride", "fiberTag", "getTag", "createFiberFromProfiler", "createFiberFromSuspense", "createFiberFromSuspenseList", "elements", "primaryChildInstance", "content", "dehydratedNode", "FiberRootNode", "hydrate", "createFiberRoot", "initialChildren", "hydrationCallbacks", "transitionCallbacks", "uninitializedFiber", "_initialState", "ReactVersion", "createPortal", "implementation", "didWarnAboutNestedUpdates", "didWarnAboutFindNodeInStrictMode", "getContextForSubtree", "parentComponent", "findHostInstance", "keys", "hostFiber", "findHostInstanceWithWarning", "methodName", "createContainer", "createHydrationContainer", "current$1", "getPublicRootInstance", "containerFiber", "attemptSynchronousHydration", "markRetryLaneIfNotHydrated", "markRetryLaneImpl", "attemptDiscreteHydration", "attemptContinuousHydration", "attemptHydrationAtCurrentPriority", "findHostInstanceWithNoPortals", "shouldErrorImpl", "shouldSuspendImpl", "overrideHookState", "overrideHookStateDeletePath", "overrideHookStateRenamePath", "overrideProps", "overridePropsDeletePath", "overridePropsRenamePath", "scheduleUpdate", "setErrorHandler", "setSuspenseHandler", "copyWithDeleteImpl", "obj", "path", "updated", "copyWithDelete", "copyWithRenameImpl", "oldPath", "newPath", "oldKey", "newKey", "copyWithRename", "copyWithSetImpl", "copyWithSet", "findHook", "newShouldErrorImpl", "newShouldSuspendImpl", "findHostInstanceByFiber", "emptyFindFiberByHostInstance", "getCurrentFiberForDevTools", "injectIntoDevTools", "devToolsConfig", "findFiberByHostInstance", "require_react_reconciler", "__commonJSMin", "exports", "module", "require_react_jsx_runtime_development", "__commonJSMin", "exports", "React", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_OFFSCREEN_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "ReactSharedInternals", "error", "format", "_len2", "args", "_key2", "printWarning", "level", "ReactDebugCurrentFrame", "stack", "argsWithFormat", "item", "enableScopeAPI", "enableCacheElement", "enableTransitionTracing", "enableLegacyHidden", "enableDebugTracing", "REACT_MODULE_REFERENCE", "isValidElementType", "type", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "getComponentNameFromType", "context", "provider", "outerName", "lazyComponent", "payload", "init", "x", "assign", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "props", "reenableLogs", "ReactCurrentDispatcher", "prefix", "describeBuiltInComponentFrame", "name", "source", "ownerFn", "match", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "c", "_frame", "syntheticFrame", "describeFunctionComponentFrame", "shouldConstruct", "Component", "prototype", "describeUnknownElementTypeFrameInDEV", "hasOwnProperty", "loggedTypeFailures", "setCurrentlyValidatingElement", "element", "owner", "checkPropTypes", "typeSpecs", "values", "location", "componentName", "has", "typeSpecName", "error$1", "err", "ex", "isArrayImpl", "isArray", "a", "typeName", "value", "hasToStringTag", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "ReactCurrentOwner", "RESERVED_PROPS", "specialPropKeyWarningShown", "specialPropRefWarningShown", "didWarnAboutStringRefs", "hasValidRef", "config", "getter", "hasValidKey", "warnIfStringRefCannotBeAutoConverted", "self", "defineKeyPropWarningGetter", "warnAboutAccessingKey", "defineRefPropWarningGetter", "warnAboutAccessingRef", "ReactElement", "key", "ref", "jsxDEV", "maybeKey", "propName", "defaultProps", "ReactCurrentOwner$1", "ReactDebugCurrentFrame$1", "setCurrentlyValidatingElement$1", "propTypesMisspellWarningShown", "isValidElement", "object", "getDeclarationErrorAddendum", "getSourceInfoErrorAddendum", "fileName", "lineNumber", "ownerHasKeyUseWarning", "getCurrentComponentErrorInfo", "parentType", "info", "parentName", "validateExplicitKey", "currentComponentErrorInfo", "childOwner", "validateChildKeys", "node", "i", "child", "iteratorFn", "iterator", "step", "validatePropTypes", "propTypes", "_name", "validateFragmentProps", "fragment", "keys", "didWarnAboutKeySpread", "jsxWithValidation", "isStaticChildren", "validType", "sourceInfo", "typeString", "children", "k", "beforeExample", "afterExample", "jsxWithValidationStatic", "jsxWithValidationDynamic", "jsx", "jsxs", "require_jsx_runtime", "__commonJSMin", "exports", "module", "isBasicObject", "value", "prototype", "isRemoteFragment", "object", "FUNCTION_CURRENT_IMPLEMENTATION_KEY", "EMPTY_OBJECT", "EMPTY_ARRAY", "createRemoteRoot", "channel", "strict", "components", "currentId", "rootInternals", "remoteRoot", "type", "rest", "initialProps", "initialChildren", "moreChildren", "normalizedInitialProps", "normalizedInitialChildren", "normalizedInternalProps", "key", "makeValueHotSwappable", "serializeProp", "child", "normalizeChild", "id", "internals", "component", "__spreadValues", "remove", "newProps", "updateProps", "children", "append", "appendChild", "removeChild", "replaceChildren", "before", "insertBefore", "makePartOfTree", "makeRemote", "moveNodeToContainer", "content", "update", "newText", "updateText", "text", "fragment", "serializeChild", "connected", "element", "tops", "_tops$get", "allDescendants", "withEach", "recurse", "perform", "remote", "local", "mounted", "IGNORE", "currentProps", "currentExternalProps", "normalizedNewProps", "hotSwapFunctions", "hasRemoteChange", "currentExternalValue", "newExternalValue", "currentValue", "newValue", "value", "hotSwaps", "tryHotSwappingValues", "isRemoteFragment", "removeNodeFromContainer", "mergedExternalProps", "hotSwappable", "seen", "tryHotSwappingArrayValues", "isBasicObject", "tryHotSwappingObjectValues", "seenValue", "result", "nested", "wrappedFunction", "args", "collectNestedHotSwappableValues", "all", "_child$parent", "container", "_currentParent$childr", "nodes", "currentParent", "existingIndex", "newChildren", "currentInternals", "getCurrentInternals", "currentChildren", "childIndex", "_currentParent$childr2", "beforeIndex", "root", "node", "parents", "newTop", "moveFragmentToContainer", "descendant", "props", "prop", "removeFragmentFromContainer", "serializeFragment", "_collectNestedHotSwap", "hasChanged", "normalizedNewValue", "currentObjectValue", "nestedHotSwappables", "newObjectValue", "updatedValue", "elementHotSwaps", "_collectNestedHotSwap2", "newLength", "currentLength", "maxLength", "i", "currentArrayValue", "newArrayValue", "createExtensionRegistrationFunction", "target", "implementation", "_shopify", "extension", "args", "__async", "channel", "components", "api", "root", "createRemoteRoot", "renderResult", "extension", "createExtensionRegistrationFunction", "Banner", "BlockStack", "Button", "Divider", "Heading", "Image", "InlineStack", "Text", "View", "import_react", "import_react", "import_react_reconciler", "createReconciler", "options", "_options$primary", "reactReconciler", "scheduleMicrotask", "context", "text", "root", "type", "allProps", "_a", "_children", "props", "__objRest", "_oldText", "newText", "_instance", "_type", "oldProps", "newProps", "updateProps", "needsUpdate", "key", "has", "instance", "payload", "remoteRoot", "child", "beforeChild", "parent", "newChild", "callback", "handleErrorInNextTick", "error", "hasOwnProperty", "object", "property", "import_react", "RenderContext", "import_jsx_runtime", "cache", "LEGACY_ROOT", "defaultReconciler", "createReconciler", "render", "element", "root", "callback", "reconciler", "defaultReconciler", "cached", "cache", "_version$split", "value", "LEGACY_ROOT", "container", "renderContext", "RenderContext", "import_react", "import_jsx_runtime", "import_react", "useRender", "render", "RenderContext", "createRemoteReactComponent", "componentType", "fragmentProps", "wrapper", "createComponentWrapper", "Component", "_a", "_b", "externalChildren", "externalProps", "__objRest", "fragments", "root", "reconciler", "useRender", "props", "children", "portals", "key", "element", "currentFragment", "fragment", "isRemoteFragment", "args", "type", "portal", "__spreadProps", "__spreadValues", "import_react", "ExtensionApiContext", "import_jsx_runtime", "reactExtension", "target", "render", "extension", "root", "api", "__async", "element", "resolve", "reject", "ExtensionApiContext", "ErrorBoundary", "error", "ErrorBoundary", "args", "error", "errorInfo", "Banner", "createRemoteReactComponent", "BlockStack", "createRemoteReactComponent", "Button", "createRemoteReactComponent", "Divider", "createRemoteReactComponent", "Heading", "createRemoteReactComponent", "Image", "createRemoteReactComponent", "InlineStack", "createRemoteReactComponent", "Text", "createRemoteReactComponent", "View", "createRemoteReactComponent", "import_react", "CheckoutUIExtensionError", "args", "ScopeNotGrantedError", "ExtensionHasNoMethodError", "method", "target", "useApi", "_target", "api", "ExtensionApiContext", "CheckoutUIExtensionError", "import_react", "useSubscription", "subscription", "setValue", "didUnsubscribe", "checkForUpdates", "newValue", "unsubscribe", "import_react", "useBuyerJourneyIntercept", "interceptor", "api", "useApi", "interceptorRef", "teardownPromise", "interceptorProps", "teardown", "useApplyAttributeChange", "api", "useApi", "ExtensionHasNoMethodError", "useShippingAddress", "shippingAddress", "useApi", "ScopeNotGrantedError", "useSubscription", "useCartLines", "lines", "useApi", "useSubscription", "useSettings", "useSubscription", "useApi", "import_react", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createVNode", "type", "props", "key", "ref", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "vnodeId", "__i", "__u", "options", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "__i", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "__r", "prevDebounce", "options", "debounceRendering", "defer", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "depthSort", "shift", "__v", "__P", "assign", "diff", "__n", "namespaceURI", "__u", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "shouldPlace", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "Array", "constructor", "String", "createVNode", "isArray", "undefined", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "parentNode", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "x", "y", "childIndex", "key", "type", "oldVNode", "matched", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "lowerCaseName", "o", "cssText", "replace", "CAPTURE_REGEX", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "undefined", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "some", "vnode", "componentWillUpdate", "componentDidUpdate", "context", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "Fragment", "cloneNode", "children", "diffChildren", "isArray", "base", "then", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "removeNode", "markAsForce", "diffElementNodes", "diffed", "forEach", "commitRoot", "root", "applyRef", "cb", "call", "node", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "EMPTY_OBJ", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "attributes", "__html", "innerHTML", "content", "getDomSibling", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "vnodeId", "createVNode", "type", "props", "key", "isStaticChildren", "__source", "__self", "ref", "i", "normalizedProps", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "vnodeId", "__i", "__u", "defaultProps", "options", "Checkout_default", "reactExtension", "u", "Extension", "query", "useApi", "cartLines", "useCartLines", "shippingAddress", "useShippingAddress", "applyAttributeChange", "useApplyAttributeChange", "settings", "useSettings", "merchantPayId", "merchantName", "firebaseProjectId", "enableManualEntry", "FIREBASE_FUNCTION_URL", "GENERATE_QR_URL", "VERIFY_PAYMENT_URL", "CHECK_STATUS_URL", "paymentReference", "setPaymentReference", "qrCodeDataUrl", "setQrCodeDataUrl", "paymentStatus", "setPaymentStatus", "showPaymentUI", "setShowPaymentUI", "verificationAttempts", "setVerificationAttempts", "errorMessage", "setErrorMessage", "cartTotal", "total", "line", "generatePaymentReference", "chars", "reference", "array", "i", "generateQRCode", "payId", "amount", "__async", "response", "result", "error", "initializePayment", "verifyPayment", "_a", "prev", "params", "useBuyerJourneyIntercept", "canBlockProgress", "renderPaymentStatus", "Banner", "BlockStack", "Divider", "Heading", "View", "InlineStack", "Text", "Image", "Button"]
}
